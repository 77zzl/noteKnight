## NumPy

> 针对**多维数组**的便捷操作！
>
> 更详细地：数据处理、清洗、构造子集、过滤、变换以及其他计算中进行快速的**向量化**计算！

多维数组： `numpy`是针对数组的高效处理工具，尤其是高维度的数组结构，但对于其他数据类型并不合适！针对其他类型的数据请移步隔壁`panda`

向量化：`numpy`提供了丰富的函数和方法来完成数组的处理工作，避免大量的循环语句也大幅度提升处理速度

<br>

### NdArray

> Numpy的核心特征——n维数组对象

`ndarray`是numpy最重要的对象，对象本身具有丰富的数组处理方法，也可利用numpy内的函数对ndarray进行处理，我们使用的所有numpy工具操作的对象都是ndarray

#### ndarray内幕

- 指向数据的指针
- dtype：数据类型，该内容将告诉系统数组中每个值的固定大小
- shape：表示数组形状的元组，该内容决定了数组的维度
- 步长元组

<br>

#### dtype

使用`.dtype`获取数组的数据类型

ndarray具有的数据类型

| 类型&类型代码         | 描述                       |
| --------------------- | -------------------------- |
| int8(i1)、uint8(u1)   | 有符号和无符号的8数位整数  |
| int32(i4)、uint32(u4) | 有符号和无符号的32数位整数 |
| float32(f)            | 标准单精度浮点数           |
| bool(?)               | 布尔值                     |

使用`.astype`更改数据类型

注意使用astype时系统总是生成一个新的数组

```python
In [3]: a = np.arange(16)

In [4]: a.dtype
Out[4]: dtype('int32')
    
In [5]: a.astype('f')
Out[5]:
array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,
       13., 14., 15.], dtype=float32)
```

可以类似于范型的做法自定义结构化的dtype，也称为嵌套dtype和多维字段

```python
In [6]: type = [('x', np.float32), ('y', np.int32)]

In [7]: arr = np.array([(1, 2), (3, 4)], dtype = type)

In [8]: arr
Out[8]: array([(1., 2), (3., 4)], dtype=[('x', '<f4'), ('y', '<i4')])
    
In [9]: arr[0]
Out[9]: (1., 2)

In [10]: arr[0]['x']
Out[10]: 1.0

In [11]: arr['x']
Out[11]: array([1., 3.], dtype=float32)

In [12]: arr['y']
Out[12]: array([2, 4])
```

<br>

#### shape

> 形状是多维数组的关键信息

使用`.shape`来查看数组的各维度信息，使用`.ndim`查看数组具有多少个维度

```python
In [14]: arr
Out[14]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [15]: arr.shape
Out[15]: (3, 4)

In [16]: arr.ndim
Out[16]: 2
```

维度是可以改变的，改变维度的操作叫做**重塑**，使用`.reshape()`来改变维度，该方法接收一个元组作为参数，元组内包含改变后的维度信息，该方法产生一个复制后的数组！

使用时需要留意，元素的总数是不变的！维度可以不断拆分

我们的系统十分聪明，可以自己补全未填写完的维度信息，也可以避免我们手误导致出错，使用`-1`补全

```python
In [17]: arr.reshape((4, 3))
Out[17]:
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])

In [18]: arr
Out[18]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])


In [22]: arr = arr.reshape((2, -1))

In [23]: arr.shape
Out[23]: (2, 6)

In [24]: arr
Out[24]:
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])
```

数组的重塑是可以规定方向的！可以留意到，之前我们的维度只有二，我们将其称为两个轴，分别为低维度的轴0和高维度的轴1，可以通俗地理解成低维的行与高维的列，而我们重塑过程中可以看到数据都按照高维顺序进行重塑，也就是`C`，我们尝试按照低维顺序重塑`F`

```python
In [24]: arr
Out[24]:
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])

In [25]: arr.reshape((3, 4), order='F')
Out[25]:
array([[ 0,  7,  3, 10],
       [ 6,  2,  9,  5],
       [ 1,  8,  4, 11]])

In [26]: arr.reshape((3, 4))
Out[26]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
```

可以看到两种不同顺序的重塑方法得到的数据全然不同

#### 转置&换轴

**转置**常见于各种线性代数中，而在numpy中转置的方式十分简单`.T`即可

注意转置并不限制于二维，高维度也可以转置

```python
In [44]: arr
Out[44]:
array([[ 0,  1,  2,  3,  4,  5,  6,  7],
       [ 8,  9, 10, 11, 12, 13, 14, 15],
       [16, 17, 18, 19, 20, 21, 22, 23]])

In [45]: arr.T
Out[45]:
array([[ 0,  8, 16],
       [ 1,  9, 17],
       [ 2, 10, 18],
       [ 3, 11, 19],
       [ 4, 12, 20],
       [ 5, 13, 21],
       [ 6, 14, 22],
       [ 7, 15, 23]])

...

In [49]: arr.shape
Out[49]: (3, 2, 4)

In [50]: arr.shape
Out[50]: (3, 2, 4)

In [51]: arr = arr.T

In [52]: arr.shape
Out[52]: (4, 2, 3)
```

**换轴**是多维数组常见的一个需求，我们希望改变轴的位置，并且希望数据也能随之改变

使用`.transpose()`置换轴的位置，参数为调换后各个轴所在的维度

```python
In [34]: arr
Out[34]:
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],

       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

In [35]: arr_trans = arr.transpose(0, 2, 1)

In [36]: arr_trans
Out[36]:
array([[[ 0,  4,  8],
        [ 1,  5,  9],
        [ 2,  6, 10],
        [ 3,  7, 11]],

       [[12, 16, 20],
        [13, 17, 21],
        [14, 18, 22],
        [15, 19, 23]]])

...

In [39]: arr_trans.shape
Out[39]: (2, 4, 3)
```

也可以使用`.swapaxes()`换轴，参数为需要调换的轴，其功能远不如transpose强大

#### 创建一个ndarray

| api                 | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| np.array()          | 将一个python类型转化为ndarray类型                            |
| np.ones()           | 初始化一个全一数组，接收一个元组作为数组的形状               |
| np.zeros()          | 初始化一个全零数组，接收一个元组作为数组的形状               |
| np.arange()         | 类似于range()，参数也一样，但初始化为一个ndarray类型，注意只能初始化一维数据 |
| np.eye()            | 初始化一个单位矩阵                                           |
| np.random.randn()   | 从均值0方差1的正态分布中抽取样本                             |
| np.random.randint() | 从给定的范围中随机抽取整数                                   |

```python
In [57]: np.random.randint(3, 10, (3, 4))
Out[57]:
array([[5, 9, 4, 7],
       [6, 5, 6, 7],
       [6, 4, 7, 6]])
```

<br>

### 向量化计算

数组的向量化计算是numpy最强大的优势，其速度将比纯python语言针对列表的计算快将近百倍，丰富的api以及numba的自定义加持使得numpy拥有充足的数组操作工具

#### 标量计算

```python
In [59]: arr
Out[59]:
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]])

In [60]: arr * 3
Out[60]:
array([[3., 3., 3.],
       [3., 3., 3.],
       [3., 3., 3.]])
```

同理加减乘除等标量计算都可以，我们可以注意到ndarray进行数组的计算非常的快

```python
In [71]: %time lst = [i * 3 for i in range(10000000)]
Wall time: 641 ms

In [72]: %time arr = np.arange(10000000) * 3
Wall time: 31.3 ms
```

之所以ndarray可以如此高速地进行运算依赖于广播机制

**广播机制**

顾名思义，将一个算数操作按照规则广播给数组中的元素称为广播机制

除了将标量广播给整个数组外，广播机制还有更大的用途！

规则总结如下：

> 想在哪个轴上进行广播，就将其设为np.newaxis，其他设为:

思考如下需求怎么优雅实现：将一个二维数组的每个值减去所在的列坐标

```python
In [89]: arr
Out[89]:
array([[7, 1, 6, 4],
       [8, 4, 0, 7],
       [3, 5, 6, 7]])

In [90]: index = np.arange(3)

In [91]: index
Out[91]: array([0, 1, 2])

In [92]: arr - index[:, np.newaxis]
Out[92]:
array([[ 7,  1,  6,  4],
       [ 7,  3, -1,  6],
       [ 1,  3,  4,  5]])
```

也可以手动的构建数组来相减，需要注意除了我们希望处理的轴是一，其他维度都必须按照原来的大小，比如上例中arr的形状为(3, 4)那么我们每列减去列数，列数的数组形状应该是(3, 1)，因为我们希望在列也就是轴1上进行操作，而其他维度的形状不变

```python
In [94]: arr - np.arange(3).reshape((3, 1))
Out[94]:
array([[ 7,  1,  6,  4],
       [ 7,  3, -1,  6],
       [ 1,  3,  4,  5]])
```

无容置疑第一种方法更加优雅