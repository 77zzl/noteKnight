# PowerBI

> 关系性Excel表

### 普通的excel表可以干啥？

明确excel表的功能：根据行列展示数据，使用函数体现数据间的关系

### 高端在哪？

- 更自由的数据展示平台
- 构建不同表间的联系以方便管理
- 快速的数据插入操作
- ······

- [ ] *猜想：PowerBi的功能全部建立在表的关系上*

<br>

## 关系型数据

> 关系的表示方式？

使用模型选项卡进行连线操作，确定类似于SQL中的关系，依靠主键关联

### 索引字段

很简单的API，'目标表'[目标字段]

索引成功的前提是该表与本表已建立关系

<br>

### 新建列的方式

- LookUpValue(目标字段，目标表上的主键，本表中的主键)

- Related('目标表'[目标字段])
  - 该函数要求本表与目标表已建立关系（模型选项卡）

<br>

### 度量值

对表内数据逻辑的呈现

可以简单的理解成excel的`sum`函数，就是对一部分数据的加合呈现

在报表选项卡中，提供了多种对数据呈现的方式，在其中使用度量值可以更简易地呈现且多样地呈现数据，甚至我们可以简单把`PowerBI`理解成报表选项卡的生成，也就是**数据建模**，而度量值就是建模中操控数据的工具！

- 度量值具有筛选功能
- 把所有需要用到的度量值放到“输入数据”并更名“度量值”的表中

***

#### Calculate

该函数发挥的就是一个筛选器的作用，可以接受多个参数，但第一个必须是待筛选的数据，往后是筛选条件，筛选条件可以有多个，不同的条件使用逗号隔开

**注意calculate返回的是新的一列**

```
多条件 = CALCULATE([总销量],'商品表'[品名] ="A",'商品表'[进价] =0.1)
```

#### Calculatetable

有时候我们的野心并不满足于新建一列，而是新建一个表，此时我们无比怀念

```sql
select * from `销售表` where `品名` = 'A' and `进价` = 0.1; 
```

不用担心，我们仅仅需要将api改变一下，就可以实现生成一张新的表的功能

```
新表 = CALCULATETABLE('销售表','商品表'[品名]="A",'商品表'[进价]=0.1)
```

#### Filter

> 高级筛选器

filter是为了辅助calculate而诞生的，将filter当作calculate的筛选条件，最后的输出结果会根据筛选规则返回需要的数值，但如果没有filter那么返回结果将是筛选后的字段集

filter也可以进行多条件筛选，按照逻辑与`&&` 

```
Calculate(表达式(度量值),Filter('表名', 筛选条件))

1班男生b = CALCULATE([总分],FILTER('花名册','花名册'[班级]="1班" && '花名册'[性别]="男"))
```

- filter参数1的表必须是一端的表

但如果我们没有这张表，但是我们有需求使用filter的功能呈现数据呢？

#### Values

有点像匿名表，因为filter要求是具有唯一值的表，我们可以将我们需要筛选的值提取出来单独成表，并使用这个表作为filter的参数1

- values具有去重功能

```
filter总分3 = CALCULATE([总分],FILTER(VALUES('成绩表'[学号]),[总分]>250))
```

<br>

### 关系

> 表间关系由表的数据确定

- 一对多
  - 在一对多关系下，一端可以从多端通过`related`函数获取字段
  - 在一对多关系下，多端可以通过`relatedtable`函数在一端中筛选数据
- 一对一
  - 在一对一关系上，获取字段和筛选数据的功能都可以用

举个例子

```
销售成本 = [销售数量]*RELATED('商品表'[进价])
```

上述例子新建列“销售成本”，且该列的数据由一端的进价乘以本表的销售数量，这个例子就是多端从一端获取字段

```
订单数量 = COUNTROWS(RELATEDTABLE('销售表'))
```

当我们在一端建立新的列“订单数量”时，该列的含义是，呈现不同商品的销售数量，而销售数量数据存在多端，当我们需要从一端访问多端数据时就需要使用`relatedtable`

<br>

### 报表选项卡

- 报表选项卡应该具有筛选功能，因此行和值不要来自同一列

<br>

### 筛选

筛选在PowerBI中是一个很重要的功能，我们首先了解一下筛选的工作机制，然后谈谈何种情况下存在筛选。

#### 机制

我们可以把筛选当成一张动态表，我们按照一定的规则从这个动态表中筛选出数据，因此在报表选项卡中假如我们把度量值放到值中，根据行的不同，呈现的数据也不同，因为这张动态表随着行的改变而变化了。

#### 场景

我们已知的是度量值具备筛选功能，这意味着我们在报表选项卡中矩阵的值填入度量值，当填入不同的行时将呈现不同的数据，可是我们也注意到，如果我们将相同的表达式`总分 = SUM('成绩表'[分数])`作为新建列时，所有行的数据都是一样的，这样的情况如何区分呢？

- 行上下文
  - 行上下文不具备筛选功能，在计算完一个确定的值后下班
  - 新建列就是行上下文
- 筛选上下文
  - 筛选上下文具有筛选功能，根据不同的行会自动筛选数据
  - 度量值就是筛选上下文
- 外部筛选
  - 切片器

这意味着相同的表达式`总分 = SUM('成绩表'[分数])`如果在度量值中那么[总分]就是度量值，其作为矩阵的值拥有筛选的作用，如果在列中则无此功能

**理解一个度量值**

```
销售表中的商品数量 = Calculate(CountRows('商品表'), '销售表') 
```

商品表中有所有的商品，而销售表中未必卖出过所有商品，在这个前提条件下我们来深入理解Calculate是怎么工作的。CountRows将统计行数，而作为参数一意味着CountRows('商品表')是被筛选的目标，最后的输出结果应该是一个数据表示行数，现在我们用销售表作为条件对其筛选，也就是我们值统计销售表中出现的商品，而商品表每个商品是唯一的，所以这个度量值表示的是：*销售表有多少种商品*

<br>

#### 转换？

- **行上下文 -> 筛选上下文**

行上下文可以通过在表达式外嵌套一层calculate使其具有筛选功能

也可以理解成，任何表达式本身都不具备筛选功能，是度量值和calculate赋予了它们这个功能

- **筛选上下文 -> 行上下文**

尽管筛选功能十分强大以及好用，但是有的时候我们并不需要它，比如当我们在计算百分比时，我们的分子可能会随着行的改变而变动，但我们并不希望分母也发生这种情况，也就是说我们希望取消掉分母的筛选功能

这时候便可使用函数`all()`达到这个目的，当all内的参数为表时，将会消除所有筛选的功能，让“动态表”停下来

- all可以无视所有筛选器的影响

```
总销量 = Sum('销售表'[销售数量]) 

禁止筛选的总销量 = Calculate([总销量], All('销售表'))

每个商品的占比 = [总销量] / [禁止筛选的总销量]
```

这个实例中我们的分母“禁止筛选的总销量”使用了`All('销售表')`消除了筛选功能，无论是度量值还是calculate都不会改变分母的值了

- 如果出现计算百分比且又有切片器的场景，使用`allselected()`

```
总销量 = Sum('销售表'[销售数量]) 

禁止筛选的总销量 = Calculate([总销量], AllSelected('销售表'))

每个商品的占比 = [总销量] / [禁止筛选的总销量]
```

当all的参数为列时同理，但需要注意

- 含有all函数的度量值必须与矩阵的行和列在同一张表上

- `AllExcept`表示消除除了选中列以外的所有列的筛选
  - 用于反向选择
- `AllNoBlankRow`返回表中除了空白行以外的所有行
  - 用于处理差集

<br>

## 函数

### 聚合函数

Sum、CountRows等都是聚合函数，略

<br>

### 迭代函数

- 根据聚合函数特性进行逐行扫描操作

迭代函数就是聚合函数后面加上X，
比如SumX。格式：
`SumX(表, 算术表达式)`

- 参数1：对哪个表进行操作
- 参数2：表达式。要做什么（新建一列）


```
列 = Calculate((SumX('表', [捡钱] - [丢钱])))
```

除了SumX以外，还有其他的AverageX、MaxX、MinX、CountX、CountaX、ProuctX等，略

<br>

### 错行处理

`earlier(字段)`

- ~~找到字段并返回索引?~~

- ~~返回所有小于等于当前行的数据~~

- 类似于两层for循环，与迭代函数配套使用，表示当前行

#### 看几个例子就懂了

```
下个订单日期 = sumx(filter('表','表'[序号]=earlier('表'[序号])+1),'表'[销售日期])
```

理解这个例子之前先复习一下`sumx`和`filter`

- sumx是一个迭代函数，接收两个参数，一个是待操作的表，一个是操作的具体内容
  - 参数一：`filter('表','表'[序号]=earlier('表'[序号])+1)`
    - filter是高级筛选器，同样接收两个参数，一个是表一个是筛选的条件，返回按照条件筛选后的表
    - 在’表‘中进行筛选
    - 筛选条件`'表'[序号]=earlier('表'[序号])+1`
      - 该条件表示寻找序号等于当前序号加一的数据，即下一个序号的数据
  - 参数二：`'表'[销售日期]`
    - 这里的日期是无法累加的，所以不会触发累加操作

**在‘表’中找到所有序号等于当前行的序号加一的行，并返回该行日期**

```
累计销量 = sumx(filter('表','表'[序号]<=earlier('表'[序号])),'表'[销售量])
```

- 这里sumx的第二个参数是销售量是可以累加的，因此会触发累加操作

- 高级筛选器筛选的内容是从‘表’中筛选所有序号小于等于当前序号的行

**在‘表’中找到所有序号小于等于当前行的行，并累加所有满足条件的销量值**

```
商品累计求和 = SUMX(FILTER('表','表'[序号]<=EARLIER('表'[序号]) && '表'[商品]=EARLIER('表'[商品])),'表'[销售量])
```

**在‘表’中找到所有序号小于等于当前行的行且商品等于当前行商品，并累加所有满足条件的销量值**

```
第几次购买 = COUNTROWS(FILTER('表1','表1'[姓名]=EARLIER('表1'[姓名]) && '表1'[序号]<=EARLIER('表1'[序号])))
```

**在‘表1’中找到所有姓名等于当前行的行且序号小于等于当前行的行，并计算满足的行个数**

<br>

### 遇错处理

`iferror(表达式，遇错替换值)`

- 有时候遇到格式错误等情况会使我们的表达式求值失败，这时候使用该函数将错误结果替换成替换值

```
销售金额 = iferror([单价] * [销售数量], 0)
```

**新建列，将单价与销售数量相乘，如果遇到报错则替换成0**

<br>

### 新建表

- value
  - 参数为表时，不会进行去重，只是单纯把表复制一次
  - 参数为字段时，会进行去重
  
- distinct
  - 参数为表时，如果是完全重复的行则会去重
  - 参数为字段时，会进行去重
  - 参数为表达式时，可以内嵌filter来对表进行筛选

- value 和 distinct 还有一个很大的区别在于，value包括没有匹配的空白行，即哪怕表中不存在这个数据，但是关系表中有，在value时也会显示出来

- DataTable

  - 人工建表

  - 参数1：字段名

  - 参数2：数据类型

  - 参数3：具体的数据。需要使用两层花括号，内层花括号代表一个记录

  - ```
    参数表2 = DataTable("姓名", String, "年龄", Integer, {{"张三", 23}, {"李四", 34}, {"王五", 55}})
    ```


<br>

### 条件判断

#### IF

`if(条件表达式，满足则该值，不满足则该值)`

就是个三目运算符，略

<br>

#### SWITCH

有两种语法可供选择

- 语法一

  - `switch(表达式，值1，结果1，…，[else])`

  - ```
    月份 = SWITCH('例3'[月], 
    1, "一月", 2,"二月",
    3, "三月", 4,"四月",
    5, "五月", 6,"六月",
    7, "七月", 8,"八月",
    9, "九月", 10,"十月",
    11,"十一月", 12,"十二月",
    "未能识别")
    ```

- 语法二

  - `switch(true(), 表达式1，结果1)`

  - ```
    年龄段 = SWITCH(
    TRUE(),
    '例4'[年龄]<30,"30岁以下",
    '例4'[年龄]<40,"30-40岁",
    '例4'[年龄]<50,"40-50岁",
    "50岁以上")
    ```

<br>

#### 布尔函数

在条件判断中需要许多逻辑判断来满足我们的业务需求，这时候powerbi提供了许多布尔函数，帮助我们快速更优雅高效的使用条件判断

- isinscope

  - 判断是否在制定层级中

  - ```
    占比层级 = 
    
    SWITCH(TRUE(),
    
    ISINSCOPE('商品表'[商品名称]), DIVIDE([总金额],CALCULATE([总金额],ALLSELECTED('商品表'[商品名称]))),
    
    ISINSCOPE('商品表'[产品类别]), DIVIDE([总金额],CALCULATE([总金额],ALLSELECTED('商品表'[产品类别]))),
    
    DIVIDE([总金额],CALCULATE([总金额],ALLSELECTED('商品表'[商品名称]))))
    ```

  - `divide`为安全除法，divide(a, b, 如果a/b不存在则返回的值)

  - 判断行是否在商品名称这个层级中，如果是则计算该行在同层商品名称中占比

  - 判断行是否在产品类别这个层级中，如果是则计算该行在同层产品类别中占比

  - 否则计算在同层商品名称中占比

- isfiltered

  - IsFiltered函数用于判断某一[字段]是否有筛选关系

- ifcrossfiltered

  - IsCrossFiltered与它相近，它用于判断某一个[表]中是否含有筛选字段
  
  - ```
    前12个月= IF (
    	ISCROSSFILTERED ( '日期表'[年月] ),
    	CALCULATE (
    		VALUES ( '表'[年月] ),
    		FILTER ('表','表'[年月序号] <= MAX ( '日期表'[年月序号] ) && '表'[年月序号]> MAX ( '日期表'[年月序号] ) - 12)
    	),
    	1
    )
    ```
  
- firstnonblank

  - 返回第一个不为空的行

  - ```
    每人第一个不为空的销售 = CALCULATE (
    	SUM ( '表'[销售] ),
    	FIRSTNONBLANK ( '表'[日期], CALCULATE ( SUM ( '表'[销售] ) ) )
    )
    ```

- lastnonblank

  - 返回最后一个不为空的行

- hasonefilter
  - 判断是否只有一个筛选（单选）
  
  - ```
    HasOneFilter总成绩 = If(HasOneFilter('案例1'[姓名]), [总分], Blank())
    ```
  
  - ```
    外汇转人民币 = If(
      HasOneFilter('汇率'[货币]), 
      FirstNonBlank('汇率'[汇率], "") * [总金额], 
      Blank()
    )
    ```
  
- ~~HasOneValue~~

  - 判断是否只有一行数据

  - 参数是列。通过和If语句搭配使用，判断某列是否只有一行数据

  - ```
    If(HasOneValue('表名'[列名]), [度量值], Blank())
    ```

- SelectedValue

  - HasOneValue + If 版本

  - 代码量更少

  - ```
    值 = switch(
    	selectedvalue('参数表'[字段名]),
    	"销售表", sum('案例3'[销售量]),
    	"销售额", sum('案例3'[销售额])
    )
    ```

<br>

### 转换函数

- currency
  - 将数字转货币格式
  - 将文本数字转货币格式
  - 将日期也能转货币格式
- int
  - 向x轴负方向取整
- trunc
  - 向零取整，直接删掉小数点
- round
  - 四舍五入

- mround
  - mround(k, x)
  - 最接近k的x的倍数

- date
  - 将数字转日期
- time
  - 将数字转时间
- convert
  - 转换为指定的类型
  - `列 = conver([销售数量] * [单价], String)`
- format
  - `列 = format(Date([年], [月], [日]), "yyyy年mm月dd日")`