# 排序

<br>

## 快速排序

### 模版

```c++
void quick_sort(int q[], int l, int r)
{
    // 递归终止条件
    if (l >= r) return;

    // 用x划分数组
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    
    // 分治处理
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

### 思路

主要的思想是分支，用一个数将数组划分成两部分，将小于自身的数划分到左边，大于自身的数划分到右边，循环结束后该数的最终位置确定，并分别对左边和右边进行递归，最终将使得整个数组递增有序。**先处理后递归。**

### 边界问题

与二分有相同的边界问题，所有边界问题最好的解决办法都是背一个模板，用模板来避免边界问题。

该边界问题其实是由**二分**和计算机除法的**上下取整**导致的。许多分治算法需要将数组划分为两个部分，但是当只剩两个相邻的数时`比如1，2`，下取整将使得平分结果为较小者`即1`，上取整将使得平分结果为较大者`即2`，这时候如果不对分治结果进行处理，将导致某一部分的区间与原区间相同`即12`，使得递归不能终止。

<br>

## 归并排序

### 模板

```c++
void merge_sort(int q[], int l, int r)
{
    // 递归终止条件
    if (l >= r) return ;
    
    // 分治
    int m = l + r >> 1;
    merge_sort(q, l, m), merge_sort(q, m + 1, r);
    
    // 归并处理
    int i = l, j = m + 1, k = 0;
    while (i <= m && j <= r) {
        // 取较小者放入tmp
        if (q[i] <= q[j]) tmp[k ++] = q[i ++];
        else tmp[k ++] = q[j ++];
    }
    // 将剩余的子数组放入tmp
    while (i <= m) tmp[k ++] = q[i ++];
    while (j <= r) tmp[k ++] = q[j ++];
    
    // 更新q
    for (int i = l, j = 0; i <= r; i ++, j ++) q[i] = tmp[j];
}
```

### 思想

同样还是分治，但是处理的顺序不同于快排，归并采用的方式是对数组先划分，划分不再按照某个数进行划分，而是单纯按照下标划分左右两个子数组，然后再进行递归。递归结束后进行归并操作，将两个有序的数组合并为一个数组。

**先递归后处理。**

<br>

# 二分

<br>

## 整数二分

### 模板

```c++
// 模板A
int bsearch_l(int l, int r)
{
    while (l < r)
    {
        // 下取整
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    // while循环结束时，l与r相等
    return l;
}

// 模板B
int bsearch_r(int l, int r)
{
    while (l < r)
    {
        // 上取整
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    // while循环结束时，l与r相等
    return l;
}
```

### 模板解释

先写`check`函数，若结果为真判断是`l`更新还是`r`更新，`l`更新的话用模板A，反之用模板B

对于模板A，若不存在查找的数，找到的值为从左往右第一个满足`check`函数条件的值；反之对于模板B，若不存在查找的数，找到的值为从右往左第一个满足`check`函数条件的值。**总的来说，上取整将找到坐标最大的目标数位置，下取整将找到坐标最小的目标数位置。**

### 思路

二分的关键在于**区间性质的不同**，数组按照某个性质分为两段，最常见的就是升序和降序，以某个数分为两段。

选择数组中间的那个数，判断其是否符合区间特性，并按照需求将区间缩小一半，即为二分。

<br>

## 浮点数二分

### 模板

```c++
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;	// 注意这里不要用位运算
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

### 思路

同样利用二分思想，但因为是浮点数二分不存在取整问题，而是转换为精度问题，只需要用精度控制循环结束即可。

可用来解决次方根问题。
