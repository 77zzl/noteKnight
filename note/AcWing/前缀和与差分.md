**要注意很重要的一点！前缀和与差分都是建立在暴力循环上的优化！**

**应当先有解决方案后再考虑前缀和或差分优化**

前缀和本身也是动态规划的思想之一



# 前缀和

- 模板

```python
# 前缀和初始化
nums = [0]
nums += list(map(int, input().split()))
for i in range(1, n + 1):
    nums[i] += nums[i - 1]

# 对于l, r内的和
ans = nums[r] - nums[l - 1]
```

- 一个不错的小技巧
  - 我们经常遇到前缀和时坐标不合法的现象这时不妨用求最大值最小值的方法解决
  - 前提是前缀和矩阵有处理边界零

```python
def get(x, y):
    # 保证坐标一定在合法区间内
    a, b = max(min(x, n), 0), max(min(y, m), 0)
```



### 矩阵前缀和应用

#### [2100. 适合打劫银行的日子](https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/)

```python
class Solution:
    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
        n = len(security)
        left, right = [0] * n, [0] * n
        for i in range(1, n):
            if security[i] <= security[i - 1]:
                left[i] = left[i - 1] + 1
            if security[n - i] >= security[n - i - 1]:
                right[n - i - 1] = right[n - i] + 1
        return [i for i in range(n) if left[i] >= time and right[i] >= time]
```

前缀和应用

- 正序遍历 求 非递增 
- 逆序遍历 求 非递减



#### [2055. 蜡烛之间的盘子](https://leetcode-cn.com/problems/plates-between-candles/)

```python
class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        n = len(s)

        l, left, plate = -1, [-1] * (n + 1), [0] * (n + 1)
        for i in range(n):
            if s[i] == '*':
                plate[i + 1] = plate[i] + 1
            else:
                l = i + 1
                plate[i + 1] = plate[i]
            left[i] = l

        r, right = -1, [-1] * (n + 1)
        for i in range(n - 1, -1, -1):
            if s[i] == '|':
                r = i + 1
                plate[i + 1] = plate[i]
            right[i] = r

        return [plate[left[j]] - plate[right[i] - 1] if left[j] + 1 > right[i] and left[j] >= 0 and right[i] >= 0 else 0 for i, j in queries]
```

前缀和应用

- 正序遍历 求 左边最近
- 逆序遍历 求 右边最近



#### AC99.激光炸弹

```python
n, r = map(int, input().split())
maxx = maxy = r = min(r, 5001)
target = [[0 for _ in range(5002)] for _ in range(5002)]

for _ in range(n):
    x, y, w = map(int, input().split())
    target[x + 1][y + 1] += w
    maxx, maxy = max(maxx, x + 1), max(maxy, y + 1)

ans = 0
for x in range(1, maxx + 1):
    for y in range(1, maxy + 1):
        target[x][y] += target[x - 1][y] + target[x][y - 1] - target[x - 1][y - 1]
        if x >= r and y >= r:
            ans = max(ans, target[x][y] - target[x - r][y] - target[x][y - r] + target[x - r][y - r])

print(ans)
```

细节拉满的一道题，先看看思路

- 分别记录下最大坐标，方便前缀和初始化时节省时间
- 对 `R * R` 进行前缀和操作
- 遍历前缀和找到 `ans`

然后说说细节：

:one: 关注 `R` 的数据范围，可以发现 `R` 远比坐标最大值大，因此在读取完 `R` 后需要留意将其值与坐标轴最大值比较取较小值避免超出地图范围

:two: 坐标最大值的取值不能比 `R` 小！这将导致遍历前缀和寻找答案时跳过答案的潜在区间



#### AcWing 1230. K倍区间

> 直接前缀和爆了 O(n²)

```python
n, k = map(int, input().split())
nums, ans = [0], 0
for _ in range(n):
    nums.append(int(input()))
    
for i in range(1, n + 1):
    nums[i] += nums[i - 1]
    
for i in range(1, n + 1):
    for j in range(i, n + 1):
        if not (nums[j] - nums[i - 1]) % k:
            ans += 1

print(ans)
```

> dp？？

```python
from collections import Counter

n, k = map(int, input().split())
nums, ans = [0], 0
for _ in range(n):
    nums.append(int(input()))
    
for i in range(1, n + 1):
    nums[i] += nums[i - 1]
    
cnt = Counter()
cnt[0] += 1
for i in range(1, n + 1):
    ans += cnt[nums[i] % k]
    cnt[nums[i] % k] += 1
    

print(ans)
```

前缀和大妙招，确实是dp思想，记录过程

注意到有等式 `not (nums[j] - nums[i - 1]) % k`，即 `(nums[j] - nums[i - 1]) % k == 0` 可推导成 `nums[j] % k == nums[i - 1] % k`，因此题目变成了求对于每一个 `nums[j]` 在之前出现过相同值的个数的问题，可利用 `cnt` 记录出现过的余数值

这里有个细节需要注意，对于 `cnt[0]` 而言是满足条件的因此需要需处理



#### AcWing 4312. 出现次数 

```python
n, m, q = map(int, input().split())
s = ' ' + input()
t = input()

ll = [0 for _ in range(n + 1)]
for i in range(m, n + 1):
    ll[i] = ll[i - 1]
    if s[i - m + 1 : i + 1] == t:
        ll[i] += 1

for _ in range(q):
    l, r = map(int, input().split())
    if m <= n and r - l + 1 >= m:
        print(ll[r] - ll[l + m - 2])
    else:
        print(0)
```

本题思想在蜡烛之间的盘子也出现过，前缀和除了用来求和同样可以用来记录目标值出现次数，与蜡烛那题相同的，除了记录次数之外还需要对询问值进行修改，这也是本题最难的地方，存在两个细节：

- 字符串 `t` 应该比 `s` 小
- `r`  与 `l` 之间应该有 `m` 的长度



# 差分

### 例子

```python
# 全 0 数组，在[2, 3]间每个数加一
nums = [0] * 5
# 从nums[2]开始往后每一位都加一
nums[2] += 1
# 从nums[3]开始往后每一位都减一
nums[3 + 1] -= 1
# 进行前缀和操作
for i in range(1, len(nums)):
    nums[i] += nums[i - 1]
# [0, 0, 1, 1, 0]
```

### 模板

```python
# 数组 nums 中 l 到 r 加 k
nums[l] += k
nums[r + 1] -= k
for i in range(1, len(nums)):
    nums[i] += nums[i - 1]
```



### [798. 得分最高的最小轮调](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/)

> 模拟超时

```python
class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        c, n = Counter(), len(nums)
        for i, num in enumerate(nums):
            d = i - num
            if (d:= i - num) < 0:
                a = Counter([j for j in range(i + 1, n + d + 1)])
                c += a
            else:
                b = Counter([j for j in range(0, d + 1)])
                d= Counter([j for j in range(i + 1, n)])
                c += b + d

        mini, maxvalue = c.most_common(1)[0]
        for i, v in c.most_common():
            if v < maxvalue:
                break
            if i < mini:
                mini = i
        
        return mini
```

> 尝试用差分优化，替换Counter

```python
# 利用差分记录区间信息
class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff, n = [0] * (len(nums) + 1), len(nums)
        for i, num in enumerate(nums):
            if (d:= i - num) < 0:
                diff[i + 1] += 1
                diff[n + d + 1] -= 1
            else:
                diff[0] += 1
                diff[d + 1] -= 1
                diff[i + 1] += 1
        minid = maxvalue = score = 0
        for i in range(n):
            score += diff[i]
            if score > maxvalue:
                minid, maxvalue = i, score
        return minid
```

观察区间不难发现，无论是 `d < 0` 还是反之，可选区间一直都是在以 `n` 为进制内连续的，进而发现新的公式免除判断

```python
class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        n = len(nums)
        diffs = [0] * n
        for i, num in enumerate(nums):
            low = (i + 1) % n
            high = (i + 1 + n - num) % n
            diffs[low] += 1
            diffs[high] -= 1
            if low >= high:
                diffs[0] += 1
        score, maxScore, idx = 0, 0, 0
        for i, diff in enumerate(diffs):
            score += diff
            if score > maxScore:
                maxScore, idx = score, i
        return idx
```

