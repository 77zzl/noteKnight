## 滑动窗口

#### [1984. 学生分数的最小差值](https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

```python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        return min(s[i] - s[i - k + 1] for i in range(k - 1, len(s))) if k > 1 and (s := sorted(nums)) else 0
```

分析一下该题，本题滑动窗口长度保持不变因此一个指针循环即可，另一个指针根据差值计算得出

在本题中为了进行压行操作，本不需要 `if/else` 即 `min(s[i] - s[i - k + 1] for i in range(k - 1, len(s)))` 已经保证了式子的正确性，但因为海象运算符只能在 `if`、`while`、`判别式` 中出现，而压行中一个 `if`必须伴随一个 `else`，因此多进行一次 `k`值的判断，也有轻微的优化作用

*本来可以简简单单写完不过就是要写两行，但为了只写一行为了帅，硬是搞得复杂了一点*



#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

- 位运算（见API）

```python
# 两种解法，分别用到两种位运算
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + r >> 1
            if nums[mid] == nums[mid ^ 1]:
                l = mid + 1
            else:
                r = mid
        return nums[l]
```

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + r >> 1
            mid += mid % 1
            if nums[mid] == nums[mid + 1]:
                l = mid + 2
            else:
                r = mid
        return nums[l]
```

- 位运算异或 `^`

```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 0 = 0
```

异或可用于算法中 `^ 1` 操作，可将奇数变成偶数，偶数变成奇数

- 位运算与 `&`

```
1 & 1 = 1
1 & 0 = 0
0 & 0 = 0
```

与在算法中可用于 `& 1` 来进行奇偶判断，偶数&1为0，奇数&1为1



## 快慢指针

- 实现一个指针的坐标为另一个指针坐标的倍数



#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

- `fast`始终是`slow`的两倍