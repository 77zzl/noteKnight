# 二分

**要明确一点：二分不仅仅是快速查找的工具，同样是寻找最优解的优质算法选择**



### 模板

> 整数二分

```python
# 取相同结果的左边
l, r = 0, n - 1
    while l < r:
        m = l + r >> 1
        if nums[m] >= x:
            r = m
        else:
            l = m + 1
    ansl = l
```

```python
# 取相同结果的右边
l, r = 0, n - 1
    while l < r:
        m = l + r + 1 >> 1
        if nums[m] > x:
            r = m - 1
        else:
            l = m
    ansr = l
```

```python
# 对于上面两种情况，可以用bisect来做，但是注意bisect的返回值处理

import bisect

# 取相同结果的左边
l = bisect.bisect_left(nums, x)
# 取相同结果的右边
r = bisect.bisect(nums, x) - 1
    
# 当查询结果大于数组长度时bisect返回数组长度
if l == n:
    print(-1, -1)
elif nums[l] == x:
    print(l, r)
# 当查询结果不等于目标值时，bisect会返回相邻的坐标
else:
    print(-1, -1)
```



> 浮点数二分

```python
while r - l > 1e-8:
    m = (l + r) / 2
    if check(m) >= x:
        r = m
    else:
        l = m
```



### AcWing 730.机器人跳跃问题

**不要觉得二分只能用在对现有数组的查找，同样可以用在对唯一结果的搜索**

*二分是 ` O(N)` 复杂度的*

```python
n = int(input())
nums = list(map(int, input().split()))

def check(mid):
    for num in nums:
        mid += mid - num
        if mid < 0:
            return False
    return True

l, r = 1, max(nums)
while l < r:
    mid = l + r >> 1
    if check(mid):
        r = mid
    else:
        l = mid + 1
print(l)
```



### AcWing 1227. 分巧克力

```python
n, k = map(int, input().split())
chocolate = []
l, r = 1, float('-inf')
for i in range(n):
    chocolate.append(sorted(list(map(int, input().split()))))
    r = max(r, chocolate[i][1])

while l < r:
    mid = l + r + 1 >> 1
    if sum((i // mid) * (j // mid) for i, j in chocolate) < k:
        r = mid - 1
    else:
        l = mid

print(l)
```

本题完美诠释了python在二分中的优越性，而二分也在本题充分体现自身的明显特点：二段性，当 `mid` 小于等于 `ans` 时答案可选当未必是最优解，当 `mid` 大于 `ans` 时答案必然在另一边



### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

这题蛮多解法的，但我就想用二分

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        def check(mid):
            for i in range(len(strs) - 1):
                if strs[i][:mid + 1] != strs[i - 1][:mid + 1]:
                    break
            else:
                return True
            return False
        
        l, r = 0, min(map(len, strs)) - 1
        while l < r:
            mid = l + r + 1 >> 1
            if check(mid):
                l = mid
            else:
                r = mid - 1

        if len(strs) > 1:
            return strs[0][:l + 1] if len(strs[0]) and check(0) else ''
        else:
            return strs[0]
```

