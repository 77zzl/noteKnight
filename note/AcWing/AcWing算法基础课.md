> 在编程学习中，算法思想和编码能力同样重要，当我有了可行的思想后，如何将设计落实在代码上需要一定的编程技巧。
>
> 因此在这份笔记中我将同时强调算法思想和编程技巧。



# 分治

> 分治最大的特点即利用问题性质的不变性，即当我处理整批数据时我用的性质与我处理其中某一小部分数据时用到的性质是一样的。按照这个特点，我们完全可以缩小问题的规模。分为先分后治和先治后分两种，前者关注于部分数据的性质，后者更在意个体数据的性质。但在整个过程中，分治所处理的问题性质都是始终不变的！改变的仅仅是规模和处理的先后顺序。

<br>

## 先治后分——快速排序

> 整体性质

### 模版

```c++
void quick_sort(int q[], int l, int r)
{
    // 递归终止条件
    if (l >= r) return;

    // 用x划分数组
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    
    // 分治处理
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

### 思路

主要的思想是分治，用一个数将数组划分成两部分，将小于自身的数划分到左边，大于自身的数划分到右边，循环结束后该数的最终位置确定，并分别对左边和右边进行递归，最终将使得整个数组递增有序。**先处理后递归。**

**一定要理解分治在快排中的重要性！快排仅仅是一个分治算法的重要例子，它代表了一类先治后分的思想。常见的分治方法如快排的二分化，即每次都把问题规模缩小一倍，但是在先治后分的特点在于：当我分治之后得到的两个部分必然具有性质上的不同！即我更关注于这一组数据中的某个部分。比如快排，它分治后一部分小于我的中间值，另一部分大于该中间值，之后我再按照我的业务逻辑去分别处理这两个部分！**

### 边界问题

与二分有相同的边界问题，所有边界问题最好的解决办法都是背一个模板，用模板来避免边界问题。

但是理解下面的原理同样重要！

**该边界问题其实是由二分和计算机除法的上下取整导致的。许多分治算法需要将数组划分为两个部分，但是当只剩两个相邻的数时`比如1，2`，下取整将使得平分结果为较小者`即1`，得到`[1, 1]与[1, 2]`；上取整将使得平分结果为较大者`即2`，得到`[1, 2]与[2, 2]`；这时候如果不对分治结果进行处理，将导致某一部分的区间与原区间相同`即[1, 2]`，使得递归不能终止。比如在下取整中我们需要对较大的区间的中间值加一，上取整中需要将较小的区间的较大值减一。**

### 技巧

#### 双指针

快排模板给到最强大的技巧莫过于它的双指针技巧了。

**当我们需要用双指针从数组的头尾向中间移动时**，使用`do - while`循环是个不错的选择，因为这种写法可以避免直接使用`while`遇到的特判问题，而这个特判问题其实是当前指针的定义问题，即我当前指针所指向的元素是我下一个要处理的元素还是处理过的元素？这个问题会导致我们不得不进行一次特判，或者不能使用`++`的写法，因此请欣赏如下优雅写法：

```c++
int i = l - 1, j = r + 1;
do i ++; while (check());
do j --; while (check());
```

在双指针算法开始前将双指针往反方向各后退一位，然后使用`do - while`循环来移动双指针。

<br>

## 先分后治——归并排序

> 个体性质

### 模板

```c++
void merge_sort(int q[], int l, int r)
{
    // 递归终止条件
    if (l >= r) return ;
    
    // 分治
    int m = l + r >> 1;
    merge_sort(q, l, m), merge_sort(q, m + 1, r);
    
    // 归并处理
    int i = l, j = m + 1, k = l;
    while (i <= m && j <= r) {
        // 取较小者放入tmp
        if (q[i] <= q[j]) tmp[k ++] = q[i ++];
        else tmp[k ++] = q[j ++];
    }
    // 将剩余的子数组放入tmp
    while (i <= m) tmp[k ++] = q[i ++];
    while (j <= r) tmp[k ++] = q[j ++];
    
    // 更新q
    for (int i = l; i <= r; i ++) q[i] = tmp[i];
}
```

### 思想

同样还是分治，但是处理的顺序不同于快排，归并采用的方式是对数组先划分，划分不再按照某个数进行划分，而是单纯按照下标划分左右两个子数组，然后再进行递归。递归结束后进行归并操作，将两个有序的数组合并为一个数组。**先递归后处理。**

**与快排的分治思想相反，归并的分治思想是先分后治。该思想的特点在于，我关心的不再是部分数据的性质而是精确到某个数据的性质。在归并排序中，我们先不断划分数据规模直到单个数据，然后再回溯进行排序，在这个过程中我们的目标是保证划分的区域内数据有序，然后再不断将两个部分的数据进行合并。**

### 技巧

#### 双指针

同样是双指针的技巧，归并排序提供了一种同时处理两个数组的双指针算法，不得不说这个算法登场率蛮高。

**当我们按顺序处理两个数组**，甚至需要完全遍历两个数组时，不妨使用`while`循环来完成此事。

```c++
// 处理需要比较的部分
while (i < m && j < r) {
    if (check()) logic(i ++);
    else logic(j ++);
}

// 处理剩余部分
if (check()) logic(i ++);
if (!check()) logic(j ++);
```

<br>

# 二分

<br>

## 整数二分

### 模板

```c++
// 模板A
int bsearch_l(int l, int r)
{
    while (l < r)
    {
        // 下取整
        int mid = l + r >> 1;
        if (a[mid] >= x) r = mid;
        else l = mid + 1;
    }
    // while循环结束时，l与r相等
    return l;
}

// 模板B
int bsearch_r(int l, int r)
{
    while (l < r)
    {
        // 上取整
        int mid = l + r + 1 >> 1;
        if (a[mid] <= x) l = mid;
        else r = mid - 1;
    }
    // while循环结束时，l与r相等
    return l;
}
```

### 模板解释

先写`check`函数，若结果为真判断是`l`更新还是`r`更新，`l`更新的话用模板A，反之用模板B

对于模板A，若不存在查找的数，找到的值为从左往右第一个满足`check`函数条件的值；反之对于模板B，若不存在查找的数，找到的值为从右往左第一个满足`check`函数条件的值。**总的来说，上取整将找到坐标最大的目标数位置，下取整将找到坐标最小的目标数位置。**

### 思路

二分的关键在于**区间性质的不同**，数组按照某个性质分为两段，最常见的就是升序和降序，以某个数分为两段。

选择数组中间的那个数，判断其是否符合区间特性，并按照需求将区间缩小一半，即为二分。

### 技巧

#### 取整问题

关于上下取整的处理可以从二分模板中学到很好的处理技巧。

当我们在处理下取整时，当只剩最后两个数，较大区间将保持与原区间一致，这时需要将较大区间的左边界放大；

同理，当我们在处理上取整时，当只剩最后两个数，较小区间将保持与原区间一致，这时需要将较小区间的右边界缩小；

```c++
// 下取整
m = l + r >> 1;
// 较小区间 [l, m] 不用变
// 较大区间 [m + 1, r] 放大

// 上取整
m = l + r + 1 >> 1;
// 较小区间 [l, m - 1] 缩小
// 较大区间 [m, r] 不用变
```

<br>

## 浮点数二分

### 模板

```c++
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;	// 注意这里不要用位运算
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

### 思路

同样利用二分思想，但因为是浮点数二分不存在取整问题，而是转换为精度问题，只需要用精度控制循环结束即可。

可用来解决次方根问题。

<br>

# 高精度

> 借助vector容器对加减乘除分别进行模拟运算

高精度的计算实际上即是人类的计算方式，对应位置相加，存储进位与更高位相加。

为了更方便的编码，这里使用`vector`并且将数据逆序放进容器中，这样的好处是当两数位数相差过大时不需要在计算过程中大量移动数据。

接着需要学习一下怎样优雅地逆序存储高精度数据进`vector`容器。

```c++
/*
不要忘记
#include <vector>
*/

string a;
vector<int> A;

cin >> a;
for (int i = a.size() - 1; i >= 0; i --) A.push_back(a[i] - '0');
```

在c/c++中将字符串相减可以得到相差的ASCII码，从而优雅地将字符转换为`int`。

最后，高精度的算法均是对手算进行模拟，而进位和借位则借助`t`(temp)变量存储，因此这里的`t`其实没有特定的含义，仅仅作为临时变量存在存储中间信息。该存储变量的设定也是实现高精度算法的关键环节。

<br>

## 高精度加法

### 模板

```c++
// c = a + b
vector<int> add(vector<int> a, vector<int> b)
{
    // t存储两数相加的信息以及进位
    int t = 0;
    // c存储最后的结果
    vector<int> c;
    
    // 只有当a和b还有t都清零才结束
    for (int i = 0; i < a.size() || i < b.size() || t; i ++)
    {
        if (i < a.size()) t += a[i];
        if (i < b.size()) t += b[i];
        // 先将t的个位放进c
        c.push_back(t % 10);
        // t存储进位
        t /= 10;
    }
    
    return c; 
}
```

<br>

## 高精度减法

### 模板

```c++
// a >= b ?
bool cmp(vector<int> a, vector<int> b)
{
    // 优先判断位数
    if (a.size() != b.size()) return a.size() >= b.size();
    // 容器中数字大小为逆序，而位数相同时应从最高位开始检索，即容器的末尾
    for (int i = a.size() - 1; i >= 0; i --)
        if (a[i] != b[i]) 
            return a[i] >= b[i];
    
    // 两者相同时返回真
    return true;
}

// c = a - b
vector<int> sub(vector<int> a, vector<int> b)
{
    vector<int> c;
    
    for (int i = 0, t = 0; i < a.size(); i ++)
    {
        t = a[i] - t;	// 先处理借位
       	if (i < b.size()) t -= b[i];	// 再进行a - b
        c.push_back((t + 10) % 10);		// 更新t
        if (t < 0) t = 1;
        else t = 0;
    }
   	// 删除前导0
    while (!c.back() && c.size() > 1) c.pop_back();
    
    return c;
}
```

### 思想

在处理高精度减法时，需要优先处理两数之间的大小关系，再进行高精度计算。

另外当出现`113 - 110 = 3`的情况时，计算结果实际上为`003`这不是我们期待的结果，因此在计算结束需要删除前导零。

### 技巧

但是高精度减法提供了许多实用的技巧值得学习。

首先是比较用数组存储的数据的大小，先判断数位再判断逐一判断。

其次是减法时常遇到借位处理。当不需要借位时，我们得到的结果是一个正数，我们可以直接放进容器中，这个时候对一个只有个位的数进行`(t + 10) % 10`相当于不做任何改变；当需要借位时，我们得到的结果是一个负值，这时我们期望的结果其实是`t + 10 - b`，那么同样可以用这个代码来解决这个问题``(t + 10) % 10`。

最后是删除前导零的方法，判断是否为零，再保证最后始终还有一位的情况下不断弹出零。

<br>

## 高精度乘法

```c++
// c = a * b
vector<int> mul(vector<int> a, int b)
{
    vector<int> c;
    
    for (int i = 0, t = 0; i < a.size() || t; i ++)
    {
        if (i < a.size()) t += a[i] * b;	// 进位加上a * b
        c.push_back(t % 10);	// 存入个位
        t /= 10;	// 更新t
    }
    // 删除前导0
    while (!c.back && c.size() > 1) c.pop_back();
    
    return c;
}
```

<br>

## 高精度除法

```c++
// c = a / b
/*
本题不要忘记
#include <algorithm>
调用这个库才能使用reverse()函数
*/
vector<int> div(vector<int> a, int b, int t)
{
    t = 0;
    vector<int> c;
    
    // 注意除法是从前往后进行的
    for (int i = a.size() - 1; i >= 0; i --)
    {
        t = t * 10 + a[i];	// 先进位
        c.push_back(t / b);	// 再除
        t %= b;	// 更新t
    }
    // 注意此时得到的c是正序，为了与后续计算匹配需要反转
    reverse(c.begin(), c.end());
    // 删除前导0
    while (!c.back() && c.size() > 1) c.pop_back();
    
    return c;
}
```

### 思想

与前面三种方法不同，除法并非从后往前计算的，而是从前往后，但为了与其他算法一起使用，本题仍然用逆序存储，这使得在编码过程中大量出现逆序遍历。

在完成除法后得到的c是正序的，为了与后续计算衔接需要另外进行一次反转。

<br>

# 前缀和与差分

<br>

## 前缀和

> 前缀和主要用于在O(1)的时间内**求出某一区域内数据之和**

### 模板

```c++
// 以下b数组为a数组的前缀和
// 一维，该模板用于求出a[i]到a[j]的数据之和
s = b[j] - b[i - 1];

// 二维，该模版用于求出a[x1][y1]到a[x2][y2]之间的数据之和
s = b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1];
// 二维，该模板用于求出a[x][y]的前缀和
b[x][y] = a[x][y] + b[x - 1][y] + b[x][y - 1] - b[x - 1][y - 1];
```

### 模板思想

实际上前缀和就是动态规划的一个特例，函数`f(i, j)`表示矩阵`1~i, 1~j`的数据之和。

前缀和思想实际上提供了一种思路，当我们需要**频繁读取某个区域内所有的元素**时不妨按照我们需要的规则先对其进行预处理，这样通过一次预处理能大量减少此后读取时需要的时间。

<br>

## 差分

> 差分主要用于在O(1)的时间内**对某一区域内所有数据进行同一数值运算**

### 模版

```c++
// 以下b数组为a数组的差分
// 一维，该模板用于对a[i]到a[j]内所有元素加c
b[i] += c;
b[j + 1] -= c;

// 二维，该模板用于对a[x1][y1]到a[x2][y2]内所有元素加c
b[x1][y1] += c;
b[x1][y2 + 1] -= c;
b[x2 + 1][y1] -= c;
b[x2 + 1][y2 + 1] += c;
```

### 模板思想

需要注意原数组、前缀和以及差分的关系，将一个数组的差分进行前缀和即可得到该数组。

差分本身并不特别，而在于与前缀和有类似的预处理思想。通过提前进行预处理得到差分数组，那么当我们需要**频繁更改某个区域内所有的元素**时将节省大量的时间。

其节省时间的方法在于，在操作开始时我们预处理得到差分数组，然后按照差分规则更改差分数组，最后再用前缀和还原为原数组。

不难发现差分思想建立在前缀和思想之上，利用了前缀的叠加思想省去频繁的遍历。

另外还需要注意差分的作用方向正好与前缀和相反，当`b[i][j] + c`时从`b[i][j]`为左上角的矩阵到整个数组最后一位都会加上`c`。

<br>

# 双指针

> 双指针分为两种
>
> - 对于一个序列，用两个指针维护一段区间（快排、最长连续不重复子序列）
> - 对于两个序列，维护某种次序（归并排序、kmp）

核心思想：将$O(n^2)$的朴素算法优化到$O(n)$​

一般优先考虑朴素暴力做法，根据暴力做法考虑是否存在大量重复的地方，对其加以处理。

### 模板

```c++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
```

双指针实际使用起来模板并不唯一，不难发现以上模板与快排、归并模板相去甚远，重点在于**如何减少重复步骤**！比如该模板中所体现的，相对朴素的做法是`j`每次都从`0`重新开始，但是对序列经过观察后发现`j`只进不退，那么对`j`的路径进行优化的过程就是双指针算法的精髓所在！



















