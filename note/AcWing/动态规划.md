# 动态规划

>  无后效性

动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。

- 无后效性给动规问题提供了利用滚动数组压缩空间的优化可能
- 无后效性的特性可以作为 `py` 解决动规问题的语法糖：

`当建立dp数组时可以边读取数据（无后效性决定了dp数组只关注已经解决的子问题）`



## y氏dp法

y总的集合角度求解 `dp` 可以说是我的动态规划启蒙了，结合一下y总的思路谈一下我对动态规划的理解

- 动态规划本质是记录状态的一种算法，比如前缀和就是动态规划的一种
- 动态规划可以划分为两个重要要素：状态表示 + 状态计算
  - 状态表示方法除了多刷题外，最重要的一点是完美表达出答案所求问题的子问题
  - 状态计算是建立在正确的状态表示上的，高度依赖于对状态表示的理解

###   

### 状态表示 and 状态计算

**状态表示**

- 一定要关注属性 (Max, Min, Count) **！！！**
- 题目有多少限制？
- 我需要多少元素可以描述清楚题目所求问题的子问题？
- 文字表示 :star2:

**状态计算**

- y氏热狗划分法
  - 按照限制条件逐层划分椭圆
  - 高度依据文字描述对一般情况进行算数划分
  - 划分时无需关注数组本身！！四维我的猪脑根本理解不了
  - 子问题必然是曾经求解过的问题
  - 何种划分情况下能够使得不重不漏
  - 能否使用等效替换的方法构建

:warning: 边界划分只关注起点即可

***

### 三题入门

>  取或不取？

#### AcWing 2. 01背包问题

```python
n, m = map(int, input().split())

dp = [[0] * (m + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    '''
    根据状态表示f(i, j)当前只看在面积小于j条件下，第i位取或不取，所以只用到v[i]
    同理，观察式子可知，对于价值，也只用到w[i]
    因此完全可以在本层进行读取
    ''' 
    v, w = map(int, input().split())
    for j in range(1, m + 1):
        # 这一步很重要，这将保证数据是否全记录下来
        dp[i][j] = dp[i - 1][j]
        if j >= v:
            dp[i][j] = max(dp[i][j], dp[i - 1][j - v] + w)

print(dp[n][m])
```

关于`python`实现动态规划也有一些小妙招，需要一定的训练加以掌握

01背包问题堪称最经典的线性规划问题，本题我们可以轻易的出状态表示，但往往没法对状态表示理解透彻，导致未能写出状态计算的公式，这里详细分析一下两者

- 状态表示：`f(i, j)` 在面积只有`j`、共有前`i`件物品的条件下，求最大值
- 这里可以想到经典的指数型枚举，取或不取的情况，能都轻松得知不取的情况为`dp[i][j] = dp[i - 1][j]`
- 如果是取呢？根据对状态表示的理解，我们已经决定要装下第 `i` 件物品，因此我们需要没放第 `i` 件物品并且空间容得下第 `i` 件物品的最大值，因此 `dp[i - 1][j - v] + w` 即为所求



> 地图走位

#### AcWing 1015. 摘花生

```python
for _ in range(int(input())):
    r, c = map(int, input().split())
    dp = [[0] * (c + 1)]
    for i in range(1, r + 1):
        dp.append([0] + list(map(int, input().split())))
        for j in range(1, c + 1):
            dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])
    print(dp[r][c])
```

本题相对简单，可以看出，当我们对状态表示和状态计算都确认时，整个程序都将简单很多



> 按序选择

#### AcWing 895. 最长上升子序列

```python
n = int(input())
nums = [0] + list(map(int, input().split()))

# 以i为结尾的子序列的最大值
dp = [0] * (n + 1)
for i in range(1, n + 1):
    dp[i] = 1
    for j in range(1, i):
        if nums[j] < nums[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

**千万**不要陷入动态规划必是二维的误区，这里我们需要反思一点：何时使用动态规划？

> 需要记录下已经求解过的子问题

当我们对题目进行模拟的时候，意识到子问题需要被记录，从而选择动规！

对于动规小白，本题状态表示和状态计算都有难度，我们思考我们需要状态表示的文字表示：以 `i` 结尾的子序列的最长位数，不难发现仅有一个限制条件即可完成题目，本题的朴素解法既是一维。此时状态计算便轻松了，我们从开头到 `i - 1` 寻找比`nums[i]`小的最大值 

> 时间优化

```python
# 贪心进阶攻略
n = int(input())
nums = list(map(int, input().split()))
# dp(i)表示长度为 i 的上升子序列最后一位的最小值
# length记录当前上升子序列的长度
dp, length = [0] * (n + 1), 0
for num in nums:
    # 利用二分从当前子序列中寻找小于num的最大值
    l, r = 0, length
    while l < r:
        mid = l + r + 1 >> 1
        if dp[mid] < num:
            l = mid
        else:
            r = mid - 1
    # 因为dp(l)表示的是长度为l的子序列末尾最小值，因此num应该在其之后的下一位
    dp[l + 1] = num
    # 更新length
    length = max(length, l + 1)
print(length)
```

贪心优化使用了一个不太常见的数据结构，记录不同长度下子序列末尾的最小值，而整个子序列的长度即为上升子序列的最长上升子序列长度



### 进阶攻略

> 摘完花生搞子序列？

#### AcWing 1212. 地宫取宝

```python
n, m, k = map(int, input().split())
w, mod = [], 1000000007
dp = [[[[0] * 14 for _ in range(k + 1)] for _ in range(m + 1)] for _ in range(n + 1)]
for _ in range(n):
    w.append(list(map(int, input().split())))
for i in range(n):
    for j in range(m):
        w[i][j] += 1

# 动规的边界问题只需要考虑起点问题
dp[1][1][1][w[0][0]] = 1
dp[1][1][0][0] = 1
# 摘花生一题中对于地图的枚举
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if (i, j) == (1, 1):
            continue
        # 对应题目对物品数量的条件
        for u in range(k + 1):
            # 注意这里需要从0开始枚举，0对应着什么都没取因此当前价值为0的情况
            for v in range(14):
                dp[i][j][u][v] += (dp[i - 1][j][u][v] + dp[i][j - 1][u][v]) % mod
                if u > 0 and w[i - 1][j - 1] == v:
                    # 这里相当于最长上升子序列里对小于i的所有情况加和
                    for c in range(w[i - 1][j - 1]):
                        dp[i][j][u][v] += (dp[i - 1][j][u - 1][c] + dp[i][j - 1][u - 1][c]) % mod
                    
print(sum(dp[n][m][k][v] for v in range(14)) % mod)
```

这题能讲的太多了，细节也很多，思维难度也大

**肝**他妈的！

首先因为太多维度了无后效性带来的语法糖用不了

其次是一个很关键的细节：价值v的取值范围是 `0` 到 `13` 题目给出的是0到12，也就是说存在价值为零的坐标，我们需要将价值为零的坐标与不取该坐标区分开来，否则将漏判很多很多情况，因为每个坐标都存在取和不取的可能性，因此我们取是0到12，将其全部加一，用0来表示不取，1表示价值为0

最后是本题最难的关键点，关于地图走位的动规相对简单，而上升子序列结合到本题则大大提升了难度。这里用了一种很暴力的解法，使用一个维度记录v的取值，表示当前所有物品的最大价值。在本坐标取的情况下，该价值等于该坐标物品的价值，而观察可知在该维度有且仅有一个坐标满足条件。最后结合上升子序列，遍历已经解决的子问题中满足条件的坐标并求和



#### AcWing 1214. 波动数列

> 这是背包想不到叭

```python
MOD = 100000007
n, s, a, b = map(int, input().split())
dp = [[0] * n for _ in range(n + 1)]

dp[0][0] = 1
for i in range(1, n):
    for j in range(n):
        dp[i][j] = (dp[i - 1][(j + a * i) % n] + dp[i - 1][(j - b * i) % n]) % MOD
print(dp[n - 1][s % n])
```

不给活路系列有增加了

本题思路太复杂了记录下来不大可能，仅记录一下可以从中学到什么：

在最开始遇到本题时面临的问题就是，其中一个限制条件导致了取值可能落在负数区间

解决方法：对原始子进行变形，根据一个整数对正整数取余必然是正数的原理（c++好像不大一样）发现了本题的思路，除此之外s的范围过大问题也因为取模得到化简

在这个过程中惊奇发现一个数学规律：假如(a + b) % c == 0必有a % c == b % c也是本题能够化简的最重要依据

**关于**本题一个很关键的点：01背包模型也就是组合模型的判断依据：取或不取 =》 `+a 还是 -b`



#### AcWing 1050. 鸣人的影分身

> 01背包

```python
t = int(input())
for _ in range(t):
    m, n = map(int, input().split())
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    for i in range(1, n + 1):
        for j in range(m + 1):
            dp[i][j] = dp[i - 1][j]
            if j >= i:
                dp[i][j] += dp[i][j - i]
    print(dp[n][m])
```

本题为我们提供了一个解决状态计算很好的思路

重新讲讲y氏椭圆划分法，表示所有能够满足状态表示的集合，而我们根据具体情况进行划分。

但在很多情况下划分的依据十分难找甚至怀疑是否是状态表示出了问题，因此提出如下几个点作为划分时的思路：

- 子问题必然是曾经求解过的问题
- 何种划分情况下能够使得不重不漏
- 能否使用等效替换的方法构建



#### AcWing 1047. 糖果

> 依旧是01背包问题

```python
n, k = map(int, input().split())
nums, dp = [0], [[float('-inf')] * k for _ in range(n + 1)]

dp[0][0] = 0
for i in range(1, n + 1):
    w = int(input())
    for j in range(k):
        dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j - w) % k] + w)
print(dp[n][0])
```

总是差一点实在是可惜啊

本题有两个没想到的点：

- 第一是属性是最大值那么就应该用max来解决而非求和，状态表示就是前i个物品中选，所选和与k的余数的所有方案的最大值

- 第二是对于所有求最大值的问题，需要注意初始化时是否起点仅有个别位置是合法方案，如果有需要专门表明合法方案位置，也就是合法起点的位置



#### AcWing 1222. 密码脱落

> 区间Dp

```python
s = input()
n = len(s)
dp = [[0] * n for _ in range(n)]

for k in range(1, n + 1):
    for l in range(n - k + 1):
        r = l + k - 1
        if k == 1:
            dp[l][r] = 1
        else:
            if s[l] == s[r]:
                dp[l][r] = dp[l + 1][r - 1] + 2
            dp[l][r] = max(dp[l + 1][r], dp[l][r - 1], dp[l][r])
        
print(n - dp[0][n - 1])
```

第一次遇到区间Dp的题目，题型很明显能看出来，一个区间一个限制条件幂方种可能

首先简单说一下本题学到的技巧，用循环表示所有可能的区间，同时满足Dp的要求（无后效性）

```python
# 枚举所有长度
for length in range(1, n + 1):
    # 枚举左端点
    for l in range(n - k + 1):
        # 计算得出右端点
        r = l + length - 1
```

还有就是区间动规的划分方式：同时存在左右端点、同时没有左右端点、仅有左端点和仅有右端点，但是某些情况下最后两种情况会将同时没有左右端点的情况涵盖，因此可以少判断一个



## 野生动规

- 动规难点也就三个

  - 状态表示
  - 状态转移
  - 初始化

  

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int: 
        # dp(i, j)表示以坐标(i, j)为右下角边长最长的正方形
        n, m, ans = len(matrix), len(matrix[0]), 0
        dp = [[0] * m for _ in range(n)]
        for i in range(n):
            dp[i][0] = int(matrix[i][0])
            if dp[i][0]:
                ans = 1
        for j in range(m):
            dp[0][j] = int(matrix[0][j])
            if dp[0][j]:
                ans = 1
        for i in range(1, n):
            for j in range(1, m):
                if int(matrix[i][j]):
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    ans = max(ans, dp[i][j])
        return ans * ans
```

> 省点空间

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int: 
        n, m, ans = len(matrix), len(matrix[0]), 0
        for i in range(n):
            for j in range(m):
                if int(matrix[i][j]):
                    if (x := not i):
                        matrix[i][j] = int(matrix[i][j])
                    if (y := not j):
                        matrix[i][j] = int(matrix[i][j])
                    if not x and not y:
                        matrix[i][j] = min(int(matrix[i - 1][j]), int(matrix[i][j - 1]), int(matrix[i - 1][j - 1])) + 1
                    ans = max(ans, matrix[i][j])
        return ans * ans
```

注意虽然空间省下来了，但是因为频繁的 `int()` 操作，总的时间复杂度反而比用 `dp` 数组的大

本题是个动态规划很灵活的例子，难点在于状态表示，否则差点用图论来做



#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        n = len(nums)
        # dp(i) 表示从 nums 中选凑成i的所有组合数
        # dp(0) 表示所有都不选有一种方案
        dp = [1] + [0] * target
        for i in range(1, target + 1):
            for j in range(n):
                if nums[j] <= i:
                    # 如果我当前选 nums[j] 作为结尾那么只需要考虑没有 nums[j] 的情况下的组合数
                    dp[i] += dp[i - nums[j]]
        return dp[-1]
```

组合数虽然不是第一次遇到了，但一直没有一个很好的解法

本题的精妙之处在于，对于每一个 `i` 都用 `j` 作为最后那个数进行尝试，因此解决了排序的问题，以下是官方描述

> 在计算 `dp[i]`的值时，nums 中的每个小于等于 i 的元素都可能作为元素之和等于 i 的排列的最后一个元素。
>

其实这也是y总讲过的，寻找最后一个不同的地方，也就是考虑凑成 `i` 的数中最后一个数是哪个数的所有情况

而其中就包含了完全背包问题中的对于每个数有无限个的情况，因此本题也可看成是完全背包的一个进阶版



### 环形问题

环形问题做过**打家劫舍**和**环形子数组**的最大和

两种环形结构其实都是考察分类讨论的情况，根据以往的动规知识可以模拟出哪些情况，而哪些情况是需要另外思考的？

这里提出环形问题比较一般的思考方式：

对于 `dp[i] = max(nums[i], nums[i] + dp[i - 1])` 可以求出从 `0` 到 `n - 1` 这个范围内连续的最大子数组

而针对环形问题不难发现，解答域落在数组的左右两边，而中间空出来的正是最小子数组，因此针对环形问题的解答空间：

- 当解答域落在同一段时：最大子数组即为答案
- 当解答域落在头尾两端时：数组总和减去最小子数组

#### [918. 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

```python
class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        maxans, maxcur, minans, mincur, s = float('-inf'), float('-inf'), float('inf'), float('inf'), 0
        for num in nums:
            maxcur, mincur = max(num, maxcur + num), min(num, mincur + num)
            maxans, minans = max(maxans, maxcur), min(minans, mincur)
            s += num
        return max(s - minans, maxans) if maxans > 0 else maxans
```



### 乘积问题



#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        maxdp, mindp, dp = nums[0], nums[0], nums[0]
        for i in range(1, n):
            maxdp, mindp = max(maxdp * nums[i], mindp * nums[i], nums[i]), min(maxdp * nums[i], mindp * nums[i], nums[i])
            dp = max(dp, maxdp)
        return dp
```

对于乘积我们不难发现：

- 当前值为**正数**时
  - 如果前面累乘的结果是正数则相乘即为最大值
  - 当前面累乘结果为负数，则会得到最小值，如果后方没有负数则当前值不该取，如果有奇数个负数则该取
- 当前值为**零**时
  - 如果整个数组除了当前位都是负数则零为答案，否则不取
- 当前值为**负数**时
  - 如果累乘是负数则可得到最大值
  - 如果累乘是正数则可得到最小值

显然这也是很明显的最大值最小值的问题，我们同时维护最大值与最小值，如果出现负数则两者**交换**。同时，我们再维护一个变量存放出现过的最大值，消除零对最大值最小值的作用



#### [1567. 乘积为正数的最长子数组长度](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)

> my code

```python
class Solution:
    def getMaxLen(self, nums: List[int]) -> int:
        maxdp, mindp, dp = int(nums[0] > 0), int(nums[0] < 0), int(nums[0] > 0)
        for i in range(1, len(nums)):
            if nums[i] == 0:
                maxdp, mindp = 0, 0
            elif nums[i] > 0:
                tmp = maxdp + 1
                if not mindp:
                    mindp = 0
                else:
                    mindp = mindp + 1
                maxdp = tmp
            elif nums[i] < 0:
                tmp = maxdp + 1
                if not mindp:
                    maxdp = 0
                else:
                    maxdp = mindp + 1
                mindp = tmp
            dp = max(maxdp, dp)
        return dp
```

这么长的答案居然是正解，看了官解学个语法糖

```python
class Solution:
    def getMaxLen(self, nums: List[int]) -> int:
        maxdp, mindp, dp = int(nums[0] > 0), int(nums[0] < 0), int(nums[0] > 0)
        for i in range(1, len(nums)):
            if nums[i] == 0:
                maxdp, mindp = 0, 0
            elif nums[i] > 0:
                maxdp, mindp = maxdp + 1, (mindp + 1 if mindp else 0)
            elif nums[i] < 0:
                maxdp, mindp = (mindp + 1 if mindp else 0), maxdp + 1
            dp = max(maxdp, dp)
        return dp
```

直接少了十行，爱了爱了



## 背包问题

**经典**问题大集合！！



### 完全背包问题

- 每种物品的数量都是无限多的

- 具有朴素和优化两个版本：**py无法**过朴素版！



#### AcWing 3. 完全背包问题

```python
# 朴素版
n, m = map(int, input().split())
dp = [[0] * (m + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    v, w = map(int, input().split())
    for j in range(m + 1):
        # 这里要注意k从0开始算起，k的循环将包括i不选或选多少的情况
        k = 0
        while j >= k * v:
            dp[i][j] = max(dp[i][j], dp[i - 1][j - v * k] + w * k)
            k += 1
print(dp[n][m])

# 优化版
n, m = map(int, input().split())
dp = [[0] * (m + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    v, w = map(int, input().split())
    for j in range(m + 1):
        dp[i][j] = dp[i - 1][j]
        if j >= v:
            dp[i][j] = max(dp[i][j], dp[i][j - v] + w)
print(dp[n][m])
```

学一下优化是如何实现：

并非每个完全背包问题的**限制条件**都是体积

```python
观察 `dp[i][j] => dp[i - 1][j - v * k] + w * k` 可推知内部包含

`dp[i - 1][j - v * 1] + 1 * w`

`dp[i - 1][j - v * 2] + 2 * w`

`...`

而`dp[i][j - v] => dp[i - 1][j - v * k] + w * (k - 1)`包含

`dp[i - 1][j - v * 1] + 0 * w`

`dp[i - 1][j - v * 2] + 1 * w`

`...`

可得`dp[i - 1][j - v * k] + w * k` == `dp[i][j - v] + w`
```

​     **注意**一个很重要的点，之所以要有 `dp[i][j] = dp[i - 1][j]` 这一步是因为：

​     利用 `dp[i][j] == dp[i][j - v] + w` 的特点进行优化

​     也就是说 `dp[i][j - v]` 是不包含 `dp[i - 1][j]` 的

​     但我们在做大小值时可忽略不计，但如果题目是方案数的话不可忽略了 `dp[i - 1][j]`



#### AcWing 1226. 包子凑数

```python
from math import gcd

n = int(input())
N = 10010
dp, w, d = [[False] * N for _ in range(n + 1)], [0], 0
for _ in range(n):
    w.append(int(input()))
    d = gcd(d, w[-1])

if d != 1:
    print('INF')
else:
    dp[0][0] = True
    for i in range(1, n + 1):
        for j in range(N):
            dp[i][j] = dp[i - 1][j]
            if j >= w[i]:
                dp[i][j] |= dp[i][j - w[i]]
    print(sum([1 for i in dp[n] if not i]))
```

动规是一种**信仰**！

本题不难发现它用的完全就是完全背包的模型，但是不再是原有的三大属性而是真假

动规在本题的思维难度则变成了状态表示，对于取前`i`个数，能否凑出`j` ？



#### AcWing 900. 整数划分

```python
M = int(1e9 + 7)
n = int(input())
dp = [[0] * (n + 1) for _ in range(n + 1)]
for j in range(1, n + 1):
    dp[1][j] = 1
    dp[j][0] = 1
for i in range(2, n + 1):
    for j in range(1, n + 1):
        k = 0
        while j >= i * k:
            dp[i][j] += dp[i - 1][j - i * k] % M
            k += 1
print(dp[n][n])
```

- 千万不要忘记背包问题是一种思想！从n个物品里面挑的思想！
- 这题难在初始化，打表后才知道怎么改



#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

> 套背包模型勉强AC

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        for word in wordDict:
            # 先枚举长度
            for lenght in range(1, n + 1):
                # 再枚举头
                for l in range(n - lenght + 1):
                    # 计算得尾
                    r = l + lenght - 1
                    if s[l:r + 1] == word:
                        dp[l][r] = True
                    else:
                        for k in range(l, r):
                            dp[l][r] |= dp[l][k] & dp[k + 1][r]
        return dp[0][n - 1]
```

状态表示：在 `l`  和 `r` 的范围内是否合法

重新思考一遍后意识到并不需要用二维记录状态，仅需要 `dp(i)` 表示 `s[:i + 1]` 是否合法即可

状态表示为：`dp[j] = s[i:j] in wordDict and dp[i]`

初始化：`dp[0] = True`

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [True] + [False] * (n)
        for i in range(n):
            for j in range(i + 1, n + 1):
                if s[i:j] in wordDict and dp[i]:
                    dp[j] = True
        return dp[n]
```

 

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

> 朴素版爆时

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins)
        # dp(i)从前i个中选体积不超过j的最小硬币选法
        dp = [[float('inf')] * (amount + 1) for _ in range(n + 1)]
        # 所有当背包体积为零时，无论选前几个都应该为零
        for i in range(n + 1):
            dp[i][0] = 0
        for i in range(1, n + 1):
            for j in range(amount + 1):
                # j - k * coins[i - 1] >= 0
                for k in range(j // coins[i - 1] + 1):
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - k * coins[i-1]] + k)
        
        return dp[n][amount] if dp[n][amount] != float('inf') else -1
```

> 完全版

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins)
        # dp(i)从前i个中选体积不超过j的最小硬币选法
        dp = [[float('inf')] * (amount + 1) for _ in range(n + 1)]
        # 所有当背包体积为零时，无论选前几个都应该为零
        for i in range(n + 1):
            dp[i][0] = 0

        for i in range(1, n + 1):
            for j in range(1, amount + 1):
                dp[i][j] = dp[i - 1][j]
                if j >= coins[i - 1]:
                    dp[i][j] = min(dp[i][j], dp[i][j - coins[i-1]] + 1)

        return dp[n][amount] if dp[n][amount] != float('inf') else -1
```



#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

> 朴素版

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        n = len(coins)
        # dp(i, j)从前i个中选，总数恰为j的方案数
        dp = [[0] * (amount + 1) for _ in range(n + 1)]
        # 总数为0的方案数是所有都不选，各有一个方案
        for i in range(n + 1):
            dp[i][0] = 1
        for i in range(1, n + 1):
            for j in range(1, amount + 1):
                for k in range(j // coins[i - 1] + 1):
                    # 完全背包问题的朴素版本
                    dp[i][j] += dp[i - 1][j - k * coins[i - 1]]
        print(dp)
        return dp[-1][-1]
```

> 完全背包真的想升级就升级

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        n = len(coins)
        dp = [[0] * (amount + 1) for _ in range(n + 1)]
        for i in range(n + 1):
            dp[i][0] = 1
        for i in range(1, n + 1):
            for j in range(1, amount + 1):
                if j - coins[i - 1] >= 0:
                    # 注意这里，当我们从朴素版优化到优化版的时候dp[i - 1][j]保留的是k = 0的情况
                    # 当我们确认当前位置可以选的时候，应该是当前值加上已经求解过的值才是
                    # dp[i][j - v]是不包含dp[i - 1][j]的
                    dp[i][j] = dp[i][j - coins[i - 1]] + dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[-1][-1]
```



#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

> 优化版动规写法

```python
class Solution:
    def numSquares(self, n: int) -> int:
        w = [i * i for i in range(1, int(n ** 0.5) + 1)]
        m = len(w)
        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][0] = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                dp[i][j] = dp[i - 1][j]
                if j >= w[i - 1]:
                    dp[i][j] = min(dp[i][j], dp[i][j - w[i - 1]] + 1)
        return dp[-1][-1]
```

> 小小优化一下

```python
class Solution:
    def numSquares(self, n: int) -> int:
        weight = [i * i for i in range(1, int(n ** 0.5) + 1)]
        m = len(weight)
        # dp(i)记录为了凑成i最小需要多少个完全平方数
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            # tmp数组存储所有方案的数量，只需要在其中寻找最小值即可
            tmp = []
            for w in weight:
                # 时间上小小优化一下
                if i - w < 0:
                    break
                tmp.append(dp[i - w])
            dp[i] = min(tmp) + 1
        return dp[-1]
```



#### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

**不是**所有完全背包都是二维的！

**不要**硬套公式！

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        # dp(i)将i拆成至少两个正整数后这些正整数的乘积的最大值
        dp = [0] * (n + 1)
        for i in range(2, n + 1):
            for j in range(1, i):
                # (i - j) * j相当于初始化
                dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)
        return dp[-1]
```



### 多重背包问题

- 朴素版与完全背包的朴素版一样
- 优化版为二进制优化方式



#### AcWing 4. 多重背包问题

```python
# 朴素版
n, m = map(int, input().split())
dp = [[0] * (m + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    v, w, s = map(int, input().split())
    for j in range(m + 1):
        dp[i][j] = dp[i - 1][j]
        k = 0
        while k <= s and v * k <= j:
            dp[i][j] = max(dp[i][j], dp[i - 1][j - v * k] + w * k); k += 1
print(dp[n][m])
```

**朴素版**没什么好讲的，主要是多了一层限制条件而已

```python
# 二进制优化版
N = 25000
n, m = map(int, input().split())
v, w, dp = [0] * N, [0] * N, [[0] * (m + 1) for _ in range(N)]
cnt = 0
for _ in range(n):
    a, b, s = map(int, input().split())
    k = 1
    while k <= s:
        cnt += 1
        v[cnt] = a * k
        w[cnt] = b * k
        s -= k
        k *= 2
    if s:
        cnt += 1
        v[cnt] = a * s
        w[cnt] = b * s
    
for i in range(1, cnt + 1):
    for j in range(m + 1):
        dp[i][j] = dp[i - 1][j]
        if j >= v[i]:
            dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i])
print(dp[cnt][m])
```

二进制优化就厉害了！

先来写写二进制优化的思想：

**结论** ：对于任意一个数都能被2的n次方凑出来！

对于 `s` 变成1（2 ** 0）个一组、2（2 ** 1）个一组、4（2 ** 2）个一组...

将v、w、dp都扩容，用空间换时间从而免去了遍历s的苦恼



### 分组背包问题

- 在原本的01背包问题上加上了组别的概念
- 但可惜万变不离其宗
- 代码几乎不变变的只有数据结构



#### AcWing 9. 分组背包问题

```python
n, m = map(int, input().split())
dp = [[0] * (m + 1) for _ in range(n + 1)]
v, w, s = [], [], []
for _ in range(n):
    s.append(int(input()))
    a, b = [], []
    for _ in range(s[-1]):
        i, j = map(int, input().split())
        a.append(i)
        b.append(j)
    v.append(a)
    w.append(b)

for i in range(1, n + 1):
    for j in range(m + 1):
        # 注意一下初始化的位置
        dp[i][j] = dp[i - 1][j]
        for k in range(s[i - 1]):  
            if j >= v[i - 1][k]:
                dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i - 1][k]] + w[i - 1][k])
print(dp[n][m])
```



## 线性动规

- 也是有模板可套的动规问题，但是千万要注意对题目的理解
- 在这类区间问题中，初始化问题一定要细致考虑！结合状态表示进行讨论分析
- 线性动规基本都可以考虑缩小一维度的空间优化
- 模板

```python
for i in range(1, n + 1):
    for j in range(1, m + 1):
        # i、j都选或者都不选
        dp[i][j] = dp[i - 1][j - 1]
        # i选j不选或相反
        dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
```

```python
for i in range(1, n):
    for j in range(i):
        if 判断条件:
            状态计算
```



#### AcWing 895. 最长上升子序列

```python
n = int(input())
v = list(map(int, input().split()))
dp = [1] * n
for i in range(1, n):
    for j in range(i):
        if v[j] < v[i]:
            dp[i] = max(dp[i], dp[j] + 1)
print(max(dp))
```



#### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0] * n
        for i in range(1, n):
            dp[i] = float('inf')
            for k in range(i):
                if nums[k] + k >= i:
                    dp[i] = min(dp[i], dp[k] + 1)
        return dp[n - 1]
```

套模板超时了

```python
# 使用小根堆优化
class Solution:
    def jump(self, nums: List[int]) -> int:
        n, heap = len(nums), []
        heapq.heappush(heap, (0, 0))
        for i in range(1, n):
            while heap:
                dp, k = heap[0]
                if nums[k] + k >= i:
                    heapq.heappush(heap, (dp + 1, i))
                    break
                else:
                    heapq.heappop(heap)
        return [dp for dp, i in heapq.nsmallest(n, heap) if i == n - 1][0]
```

线性动规不用贪心做法的超强优化！

- 直接根据模板进行改造
- 原本模板的含义在于从i前所有满足条件的dp中寻找最小值，在这里将寻找最小值的操作交给小根堆实现



#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

> 直接套模板WA了

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [0] * n
        for i in range(1, n):
            # dp(i)表示i及i前抛出所得的最大利润，即i可卖出也可不卖（忽略该点，直接继承上一个点的值）
            dp[i] = dp[i - 1]
            for k in range(i):
                # 入股点k存放k及k前卖出的最大理论加上k进i出的最大利润与上一个最大利润值比较
                dp[i] = max(dp[i], prices[i] - prices[k] + dp[k])
        return dp[n - 1]
```

> 小根堆优化勉C

```python
'''
prices[i] - prices[k] + dp[k]
	= prices[i] - (price[k] - dp[k])
求上述公式的最大值也可以理解成求
price[k] - dp[k]的最小值
用一个小根堆维护每个坐标的price[i] - dp[i]即可
'''
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp, heap = [0] * n, []
        heapq.heappush(heap, prices[0])
        for i in range(1, n):
            dp[i] = max(dp[i - 1], prices[i] - heapq.nsmallest(1, heap)[0])
            heapq.heappush(heap, prices[i] - dp[i])
        return dp[n - 1]
```

> 贪心一出法力无边

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum(prices[i] - prices[i - 1] for i in range(1, len(prices)) if prices[i] > prices[i - 1])
```

贪心甚至短到可以压行

原理很简单，我们选择最佳的股票买卖点必然是一个**递增的子数组**，而且题目说明可以购买多只股票，因此只需贪心求出数组中所有递增的**差值**即可



#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 1:
            return 0
        dp = [0] * n
        for i in range(1, n):
            dp[i] = dp[i - 1]
            for k in range(i):
                if k < 2:
                    dp[i] = max(dp[i], prices[i] - prices[k])
                else:
                    dp[i] = max(dp[i], prices[i] - prices[k] + dp[k - 2])
        return dp[-1]
```

状态表示：`dp[i]`

`i` 点卖出可得的最大利润

虽然只是 `O(n^2)` 但明显有更优化的做法

本题因为有冷冻期的概念因此状态计算（状态转移）表达式为：

`dp[i] = max(dp[i], prices[i] - prices[k] + dp[k - 2])`

> 打死我也想不出来啊

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # buy 当天买入，即持有股票 —— 前一天已经持有股票与今天买入对比 (将 prices[i] - prices[k] + cd 的后两项先存进来)
        # sell 当天卖出 —— 前一天买入的价格加上今天卖出的价格
        # cd 未持股，处于冷冻期 —— 前一天也是冷冻期的利润与前一天卖出的利润
        buy, sell, cd = -prices[0], 0, 0
        for price in prices:
            buy, sell, cd = max(cd - price, buy), buy + price, max(cd, sell)
        return max(sell, cd)
```

[详细题解看这里叭！](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/by-flix-7ax0/)



#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

有了昨天的铺垫，今天**不用打死我**也想出来了！

我将状态表示的含义略加修改，使得本题的状态表示更容易被理解，但再次之前空仓概念：

[空仓：指投资者将所持有的商品（如商品、原料、股票、期货、币品等）全部抛出，手中持有现金而无商品的状态](https://baike.baidu.com/item/%E7%A9%BA%E4%BB%93/3070255?fr=aladdin)

到达空仓状态有两种可能：

1. 前一天也是空仓，今天继承前一天空仓时所得最大利润
2. 今天卖出股票达到空仓状态

**特别注意**：因为始终只有一支股票，所以不存在今天卖出今天买入的可能性：卖出即表示当前是周围的最高点，此时买入成本将变得很高

另一种状态表示定义为：当天持有股票的最大利润

1. 前一天持有的股票成本
2. 今天买入的股票成本

想要表达今天卖出股票时的最大利润需要包含两个方面：

1. 今天卖出的价格与成本间的差价已经需要扣除的手续费，即利润：`price - fee - 成本 ` 
2. 买入当天的空仓最大利润时多少，即买入前已经赚到的钱：`sold`

可得 `price - fee - 成本 + sold`

而其中 `- fee - 成本 + sold` 都由买入点提供，因此不妨在买入时即表示这个状态，在状态计算中只需要寻找最优买入点即可

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        # hold —— 当天持有股票的最大利润
        # sold —— 当天空仓的最大利润
        hold, sold = float('-inf'), 0
        for price in prices:
            hold, sold = max(hold, -price - fee + sold), max(sold, hold + price)
        return max(hold, sold)
```





#### AcWing 897. 最长公共子序列 & [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```python
n, m = map(int, input().split())
a = ' ' + input()
b = ' ' + input()
dp = [[0] * (m + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    for j in range(1, m + 1):
        if a[i] == b[j]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1])
print(dp[n][m])
```

```python
# 减少判断优化一下
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        # dp(i, j) 在text1[:i + 1]和text2[:j + 1]中最长公共子序列
        text1, text2 = ' ' + text1, ' ' + text2
        n, m = len(text1), len(text2)
        dp = [[0] * m for _ in range(n)]
        for i in range(1, n):
            for j in range(1, m):
                if text1[i] == text2[j]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
        return dp[-1][-1]
```



#### AcWing 902. 最短编辑距离 

```python
n = int(input())
a = ' ' + input()
m = int(input())
b = ' ' + input()

# dp(i, j)记录a的前i个要变成和b的前j个一样需要多少编辑次数
dp = [[0] * (m + 1) for _ in range(n + 1)]

# 需要注意到，本题的初始化比较特殊，当某一边为0时，另一边的长度即为需要编辑的次数
for i in range(n + 1):
    dp[i][0] = i
for j in range(m + 1):
    dp[0][j] = j

for i in range(1, n + 1):
    for j in range(1, m + 1):
        if a[i] == b[j]:
            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
        else:
            dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1)

print(dp[n][m])
```

本题对状态表示的理解要求很高，首先是初始化边界问题时的确定以及不同划分方式的状态计算都高度依赖状态表示

- `a[i] != b[j]`
  - 增加 + 删除：针对两个字符串其实这两个操作有点雷同均是`dp[i - 1][j] + 1 ` `dp[i][j - 1] + 1`
  - 替换：`dp[i - 1][j - 1] + 1`

- `a[i] == b[j]`
  - `dp[i - 1][j - 1]`



#### [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

```python
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        # 长度为 cur 选连续 m 个的方案数：cur - m + 1
        # 寻找连续的等差数列长度求出其方案数即可
        # 如果长度不到三直接返回零
        if (n := len(nums)) < 3:
            return 0
        ans, cur, diff = 0, 2, nums[1] - nums[0]
        for i in range(2, n):
            if (tmp := nums[i] - nums[i - 1]) == diff:
                cur += 1
            else:
                ans += sum(cur - m + 1 for m in range(3, cur + 1))
                cur, diff = 2, tmp
        # 处理末尾的cur
        ans += sum(cur - m + 1 for m in range(3, cur + 1))
        return ans
```

虽然没用动规做但还是记录一下，模拟大法好呀！

但本题确实没有动规的必要，完全不需要记录很多状态



#### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

```python
class Solution:
    def numDecodings(self, s: str) -> int:	
        n = len(s)
        # 初始化边界情况，表示当什么都不取时也是一种合法情况
        dp = [1] + [0] * n
        for i in range(1, n + 1):
            # 数位为一时不能为零
            if int(s[i - 1]):
                dp[i] = dp[i - 1]
            # 数位为二时，首位不能为零，整体小于等于二十六
            if i > 1 and int(s[i - 2]) and int(s[i - 2:i]) <= 26:
                dp[i] += dp[i - 2]
        return dp[-1]
```

这一题 [官方题解](https://leetcode-cn.com/problems/decode-ways/solution/jie-ma-fang-fa-by-leetcode-solution-p8np/) 写的蛮好的

本题的解体关键主要是多进行模拟，考虑特判最少的状态转移

在本题重点在于对**零**的判断

> 空间优化

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        # a -> dp[i - 2]
        # b -> dp[i - 1]
        # c -> dp[i]
        a, b, c = 0, 1, 0
        n = len(s)
        # dp = [1] + [0] * n
        for i in range(1, n + 1):
            # 每轮循环开始时需要清空 dp[i]
            c = 0
            if int(s[i - 1]):
                # dp[i] = dp[i - 1]
                c = b
            if i > 1 and int(s[i - 2]) and int(s[i - 2:i]) <= 26:
                # dp[i] += dp[i - 2]
                c += a
            # 循环结束时需要更新a, b的最新位置
            a, b = b, c
        return c
```



#### [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1
        a, b, c = 1, 1, 1
        for i in range(2, n + 1):
            two, three, five = dp[a] * 2, dp[b] * 3, dp[c] * 5
            dp[i] = min(two, three, five)
            if dp[i] == two:
                a += 1
            if dp[i] == three:
                b += 1
            if dp[i] == five:
                c += 1
        return dp[-1]
```

本题还是依赖模拟

琢磨一下题意：丑数是只包含质因数 `2` `3` `5` 的数，因此只需要将这三个数从 `1` 开始相乘，即可得到解答集



#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)
        # 初始化边界
        dp[0], dp[1] = 1, 1
        # 枚举长度从2到n
        for i in range(2, n + 1):
            # 枚举根节点
            for j in range(1, i + 1):
                # j - 1 表示左子树，即小于根节点的节点
                # i - j 表示右子树，即大于根节点的节点
                dp[i] += dp[j - 1] * dp[i - j]
        return dp[n]
```

举个例子 **n = 4**

```python
# D(根节点[左子树][右子树])
					D(1[][234])
		    |            |          |
		D(2[][34])  D(3[2][4])  D(4[23][])
  		  两种方案      一种方案     两种方案
			|						|
D(3[][4]) + D(4[3][])		D(2[][3]) + D(3[2][])
```

通过观察可得当我从 n 个序列中选其中 m 为根节点时
`D(m[i for i in range(1, n + 1) if i < m][j for j in range(1, n + 1) if j > m])`
举个例子，从长度为 4 的序列中选 3 作为根节点时
`D(3[12][4])`
而此时的方案由左子树和右子树提供，通过模拟不难发现当序列长度为二时无论序列内容只有两种情况
同理我们可以推知方案数只与序列长度有关
那么关于长度为 **i** 的方案由长度不同的左右子树的**笛卡尔积**而来 `dp[i] += 左子树 * 右子树`



#### [76. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        # up(i)记录前i个序列中以峰结尾的摆动序列的最长长度
        up = [1] + [0] * (n - 1)
        # down(i)记录前i个序列中以谷结尾的摆动序列的最长长度
        down = [1] + [0] * (n - 1)
        for i in range(1, n):
            # 如果当前值大于前一个值则峰不变，谷可变为峰
            if nums[i] > nums[i - 1]:
                up[i] = up[i - 1]
                down[i] = max(down[i - 1], up[i - 1] + 1)
            # 如果当前值小于前一个值则谷不变，峰可变为谷
            elif nums[i] < nums[i - 1]:
                down[i] = down[i - 1]
                up[i] = max(up[i - 1], down[i - 1] + 1)
            # 如果前后相等则不构成摆动序列，谷峰皆继承上一个值即可
            else:
                up[i], down[i] = up[i - 1], down[i - 1]
        return max(up[-1], down[-1])
```

本题其实就是子序列问题的变形，不难发现状态表示是及其相近的，**注意**其实两个 `dp` 模型都在维护用一个波动序列也就是 `up(i)` 和 `down(i)` 实际上是交替发生的，而非存在多条序列



## 区间动规

- 欢迎来到 `l` 和 `r` 的世界
- 区间动规的边界问题在于`length == 1`的情况

- 区间动规的枚举方法和划分方法总结如下：

```python
# 枚举方法
for length in range(1, n + 1):
    for l in range(n - length + 1):
        r = l + length - 1
```

```python
# 划分方法
1. l,r 都取
dp[l][r] = dp[l + 1][r - 1]

2. l 取 r 不取 或者 r 取 l 不取
dp[l][r] = min(dp[l][r - 1], dp[l + 1][r])

3. AB划分
for i in range(l, r):
    dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r])
```



#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```python
# 模板题套模板
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n, ans, cur = len(s), s[0], 1
        dp = [[0] * n for _ in range(n)]
        for length in range(1, n + 1):
            for l in range(n - length + 1):
                if length == 1:
                    dp[l][l] = 1
                    continue
                r = l + length - 1
                dp[l][r] = max(dp[l + 1][r], dp[l][r - 1])
                if s[l] == s[r]:
                    dp[l][r] = max(dp[l][r], dp[l + 1][r - 1] + 2)
                    if length > cur:
                        ans, cur = s[l:r + 1], length
        return dp[0][-1]
```

```python
# 模板竟有不为人知的优化
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for length in range(1, n + 1):
            for l in range(n - length + 1):
                if length == 1:
                    dp[l][l] = 1
                    continue
                r = l + length - 1
                # 出现回文情况必然远比未出现的好，因此只要出现了直接取
                if s[l] == s[r]:
                    dp[l][r] = dp[l + 1][r - 1] + 2
                # 否则继承就好
                else:
                    dp[l][r] = max(dp[l + 1][r], dp[l][r - 1])
        return dp[0][-1]
```



#### AcWing 282. 石子合并

```python
n = int(input())
dp = [[0] * (n + 1) for _ in range(n + 1)]
s = [0] + list(map(int, input().split()))
for i in range(1, n + 1):
    s[i] += s[i - 1]

for length in range(2, n + 1):
    for l in range(1, n - length + 2):
        r = l + length - 1
        dp[l][r] = float('inf')
        for k in range(l, r):
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l - 1])
        
print(dp[1][n])
```

我是**大冤种**系列又增加了！

做了几题区间动规还是没做出石子合并，不要被模板套死呀！注意实际问题实际讨论

- 状态表示：从l到r代价的最小值
- 状态计算：用k作为隔板求每一种石子合并方法最小值



#### AcWing 1222. 密码脱落

```python
s = input()
n = len(s)
dp = [[0] * n for _ in range(n)]

for length in range(1, n + 1):
    for l in range(n - length + 1):
        r = l + length - 1
        if length == 1:
            dp[l][r] = 1
        else:
            if s[l] == s[r]:
                dp[l][r] = dp[l + 1][r - 1] + 2
            dp[l][r] = max(dp[l + 1][r], dp[l][r - 1], dp[l][r])

print(n - dp[0][n - 1])
```

区间动规小小入门，本题十分友好呀，对于回文问题都可以套用此模板



#### AcWing 1070. 括号配对

```python
a, b = ('[', ']'), ('(', ')')
s = input()
n = len(s)
dp = [[0] * n for _ in range(n)]
for i in range(n):
    dp[i][i] = 1

for length in range(2, n + 1):
    for l in range(n - length + 1):
        r = l + length - 1
        dp[l][r] = float('inf')
        if (s[l], s[r]) == a or (s[l], s[r]) == b:
            dp[l][r] = dp[l + 1][r - 1]
        if l < n - 1 and r > 0:
            dp[l][r] = min(dp[l][r], dp[l + 1][r] + 1, dp[l][r - 1] + 1)
        for k in range(l, r):
            dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r])
            
print(dp[0][n - 1])
```

做完本题大致掌握了对区间动规的划分方法，当然和01背包问题一样，不同的限制条件会带来不同的状态计算



## 树型动规

- 感觉只是长，逻辑而言是最简单的动规
- 目前接触的仅有两种模型
  - 自顶向下
  - 自下而上

- 模板

```python
# 自下而上
def dfs(u, father):
    # 如果逻辑不需要，叶子节点判断可省略
    if 叶子节点:
        return
    for son in grid[u]:
        if son != father:
            dfs(son, u)
            逻辑语句
```

```python
# 自顶向下
def dfs(u, father):
    # 如果逻辑不需要，叶子节点判断可省略
    if 叶子节点:
        return
   	for son in grid[u]:
        if son != father:
            逻辑语句
            dfs(son, u)
```



#### AcWing 285. 没有上司的舞会 

```python
from collections import defaultdict
import sys

# python直接写容易爆栈
limit = 10000
sys.setrecursionlimit(limit)

n = int(input())
w = [0]
dp = [[0] * 2 for _ in range(n + 1)]
grid = defaultdict(list)
for _ in range(n):
    w.append(int(input()))
for _ in range(n - 1):
    u, v = map(int, input().split())
    grid[u].append(v)
    grid[v].append(u)

def dfs(u, father):
    if len(grid[u]) == 1 and grid[u][0] == father:
        dp[u][1] = w[u]
        return max(0, dp[u][1])
    dp[u][1] = w[u]
    for son in grid[u]:
        if son == father:
            continue
        dfs(son, u)
        # 父节点不来，子节点可来可不来
        dp[u][0] += max(dp[son][0], dp[son][1])
        # 父节点来，子节点必不能来
        dp[u][1] += dp[son][0]
    return max(dp[u][0], dp[u][1])

dfs(1, 0)
print(max(max(i) for i in dp))
```

本题有点像01背包问题套到了树型动规身上



#### AcWing 1078. 旅游规划

```python
from collections import defaultdict

grid = defaultdict(list)
n = int(input())
d1, d2, up, p, maxd = [0] * n, [0] * n, [0] * n, [0] * n, 0
for _ in range(n - 1):
    u, v = map(int, input().split())
    grid[u].append(v)
    grid[v].append(u)

# 自下而上
def dfs_d(u, father):
    for son in grid[u]:
        if son == father:
            continue
        # 先子节点后操作父节点
        dfs_d(son, u)
        distance = d1[son] + 1
        if distance > d1[u]:
            d1[u], d2[u], p[u] = distance, d1[u], son
        elif distance > d2[u]:
            d2[u] = distance
    global maxd
    maxd = max(maxd, d1[u] + d2[u])
    
# 自顶向下
def dfs_u(u, father):
    for son in grid[u]:
        if son == father:
            continue
        up[son] = up[u] + 1
        if son == p[u]:
            up[son] = max(up[son], d2[u] + 1)
        else:
            up[son] = max(up[son], d1[u] + 1)
        # 先操作父节点后递归子节点
        dfs_u(son, u)

dfs_d(0, -1)
dfs_u(0, -1)
for i in range(n):
    d = max(d2[i], up[i])
    if d + d1[i] == maxd:
        print(i)
```

本题相对而言难很多，同时具有自顶向下和自下而上两种结构

但也提醒了我们一点：动规的核心思想在于存储过程

对于每一个节点，记录它出发向父节点的路径最大值、它出发向下的路径最大值与次大值

树型动规也就模板背过实际问题实际讨论就好



## 数位统计DP

- 讲真有点麻，虽然这种分类讨论的思想很好



#### AcWing 338. 计数问题

> 某大佬代码

```python
# 计算1 ~ n中一共有多少x
def count(n, x):
    cnt = 0
    seq = str(n)
    l = len(seq)

    # x == 0    1 ~ l
    # 反之      0 ~ l
    # i表示统计x处在每一位上的出现次数，而0不能在第一位！

    for i in range(not x, l):
        # 先计算0 ~ abc - 1
        if i:
            cnt += (int(seq[:i])) * pow(10, l - i - 1)
            # 如果当前所求x为零，则需要减去相应数值
            if not x:
                cnt -= pow(10, l - i - 1)

        if int(seq[i]) == x:
            # int()不能处理空字符串
            if seq[i + 1:]:
                cnt += int(seq[i + 1:])
            cnt += 1
            # cnt += int(seq[i + 1:]) + 1
        elif int(seq[i]) > x:
            cnt += pow(10, l - i - 1)
    return cnt

def solution():
    while 1:
        a, b = map(int, input().split())
        if a == b == 0:
            break
        res = []
        # 枚举0 ~ 9每个数
        for i in range(10):
            # 保证a < b
            if a > b:
                a, b = b, a
            res.append(count(b, i) - count(a - 1, i))
        print(' '.join(map(str, res)))


if __name__ == '__main__':
    solution()
```

因为没看懂y总视频打算直接肝代码思路还是不变的

**count(n, x) :从 `1` 到 `n` 中 `x` 出现过多少次**
分类讨论：

- 设所在位置 `i` 前有 `abc` 当 `0 ~ abc - 1` 时的所有情况：
  - `int(abc) * pow(10, l - i - 1)`
  - `x` 为零时 `i` 不能为零因为不符合条件
  - 其他情况下，`i` 为零不用考虑当 `0 ~ abc - 1` 时的情况

- 当 `abc` == `abc` 时的所有情况：
  - `n` 的 `i` 位恰好为 `x` ：
    - `int(seq[i + 1:]) + 1`
    - 注意`int()`不能转换空字符
  - `n` 的 `i` 位大于 `x` ：
    - `pow(10, l - i - 1)`



## 状态压缩

- 用01记录世界

- 状压也是一种思想并没有模板



#### AcWing 291. 蒙德里安的梦想

```python
while True:
    n, m = map(int, input().split())
    if not n | m:
        break
    
    # st记录当前棋盘下何种方案是可行的：不能出现奇数个连续的零
    st = [True] * (1 << n)
    # 枚举每一种方案
    for i in range(1 << n):
        # cnt记录连续的零的个数
        cnt = 0
        for j in range(n):
            # 如果当前位是一
            if i >> j & 1:
                # 记录为奇数个
                if cnt & 1:
                    # 该方案不可行
                    st[i] = False
                    break
                # 清空记录
                cnt = 0
            else:
                cnt += 1
        # 处理末尾连续的零
        if cnt & 1:
            st[i] = False
    
    # dp[i][j]记录第i列下的第j种方案的可行解数目
    dp = [[0] * (1 << n) for _ in range(m + 1)]
    # 初始化边界
    # 第零列只有啥都不选才是解，有点抽象
    dp[0][0] = 1
    # 枚举每一列
    for i in range(1, m + 1):
        # 枚举第i列的每一种方案
        for j in range(1 << n):
            # 枚举第i - 1列的所有方案
            for k in range(1 << n):
                # 只有当两种方案求与后不重叠、没有连续个奇数的零时才是合法解
                if not j & k and st[j | k]:
                  	# 本列的可选方案依赖于前一列的方案选择
                    dp[i][j] += dp[i - 1][k]
    # 第m列全都不选才是本题最终答案
    print(dp[m][0])
```

状压的思想其实在深搜里面接触过了，利用二进制来代替对每一种方案的记录，更多的是优化空间操作

本题同样用了一种很有意思的思想：等价替换，在开关那题中只要确定了第一列的开关选择后面的每一列操作都被确定了下来，而在本题中，存在一种格子两种摆放方法，也是当一种确定下来后另一种也被确定，利用这个思想大大降低思维难度



#### AcWing 91. 最短Hamilton路径

```python
n = int(input())
dp, w = [[float('inf')] * (1 << n) for _ in range(n)], []
for _ in range(n):
    w.append(list(map(int, input().split())))
    
# dp[j][i]记录从零到第j个点时，经过了i（用整数的二分记录）点
dp[0][1] = 0
for i in range(1 << n):
    for j in range(n):
        if i >> j & 1:
            # k用来寻找在i的方案下，除了j点外的点
            for k in range(n):
                # i - (1 << j)删掉状态中包含了j的记录
                if (i - (1 << j)) >> k & 1:
                    dp[j][i] = min(dp[j][i], dp[k][i - (1 << j)] + w[k][j])
print(dp[n - 1][(1 << n) - 1])
```

对于刚刚那题还没感觉，现在明白了

- 状态计算的特点是把多种状态用一个整数的二进制表示直接放进dp中
- 关于状压的题目需要多寻找降维的方法，很多时候一个条件确定下来其他条件也被确定了



**要注意很重要的一点！前缀和与差分都是建立在暴力循环上的优化！**

**应当先有解决方案后再考虑前缀和或差分优化**

前缀和本身也是动态规划的思想之一



## 前缀和

- 前缀和是动规思想很好的应用
  - 对一段连续区域内的数据求和
  - 记录一段连续区域内的数据特性（单调性、左右邻近极值）
- 模板

```python
# 前缀和初始化
nums = [0]
nums += list(map(int, input().split()))
for i in range(1, n + 1):
    nums[i] += nums[i - 1]

# 对于l, r内的和
ans = nums[r] - nums[l - 1]
```

- 一个不错的小技巧
  - 我们经常遇到前缀和时坐标不合法的现象这时不妨用求最大值最小值的方法解决
  - 前提是前缀和矩阵有处理边界零

```python
def get(x, y):
    # 保证坐标一定在合法区间内
    a, b = max(min(x, n), 0), max(min(y, m), 0)
```



#### [2100. 适合打劫银行的日子](https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/)

```python
class Solution:
    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
        n = len(security)
        left, right = [0] * n, [0] * n
        for i in range(1, n):
            if security[i] <= security[i - 1]:
                left[i] = left[i - 1] + 1
            if security[n - i] >= security[n - i - 1]:
                right[n - i - 1] = right[n - i] + 1
        return [i for i in range(n) if left[i] >= time and right[i] >= time]
```

前缀和应用

- 正序遍历 求 非递增 
- 逆序遍历 求 非递减



#### [2055. 蜡烛之间的盘子](https://leetcode-cn.com/problems/plates-between-candles/)

```python
class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        n = len(s)

        l, left, plate = -1, [-1] * (n + 1), [0] * (n + 1)
        for i in range(n):
            if s[i] == '*':
                plate[i + 1] = plate[i] + 1
            else:
                l = i + 1
                plate[i + 1] = plate[i]
            left[i] = l

        r, right = -1, [-1] * (n + 1)
        for i in range(n - 1, -1, -1):
            if s[i] == '|':
                r = i + 1
                plate[i + 1] = plate[i]
            right[i] = r

        return [plate[left[j]] - plate[right[i] - 1] if left[j] + 1 > right[i] and left[j] >= 0 and right[i] >= 0 else 0 for i, j in queries]
```

前缀和应用

- 正序遍历 求 左边最近
- 逆序遍历 求 右边最近



#### AC99.激光炸弹

```python
n, r = map(int, input().split())
maxx = maxy = r = min(r, 5001)
target = [[0 for _ in range(5002)] for _ in range(5002)]

for _ in range(n):
    x, y, w = map(int, input().split())
    target[x + 1][y + 1] += w
    maxx, maxy = max(maxx, x + 1), max(maxy, y + 1)

ans = 0
for x in range(1, maxx + 1):
    for y in range(1, maxy + 1):
        target[x][y] += target[x - 1][y] + target[x][y - 1] - target[x - 1][y - 1]
        if x >= r and y >= r:
            ans = max(ans, target[x][y] - target[x - r][y] - target[x][y - r] + target[x - r][y - r])

print(ans)
```

细节拉满的一道题，先看看思路

- 分别记录下最大坐标，方便前缀和初始化时节省时间
- 对 `R * R` 进行前缀和操作
- 遍历前缀和找到 `ans`

然后说说细节：

:one: 关注 `R` 的数据范围，可以发现 `R` 远比坐标最大值大，因此在读取完 `R` 后需要留意将其值与坐标轴最大值比较取较小值避免超出地图范围

:two: 坐标最大值的取值不能比 `R` 小！这将导致遍历前缀和寻找答案时跳过答案的潜在区间



#### AcWing 1230. K倍区间

> 直接前缀和爆了 O(n²)

```python
n, k = map(int, input().split())
nums, ans = [0], 0
for _ in range(n):
    nums.append(int(input()))
    
for i in range(1, n + 1):
    nums[i] += nums[i - 1]
    
for i in range(1, n + 1):
    for j in range(i, n + 1):
        if not (nums[j] - nums[i - 1]) % k:
            ans += 1

print(ans)
```

> dp？？

```python
from collections import Counter

n, k = map(int, input().split())
nums, ans = [0], 0
for _ in range(n):
    nums.append(int(input()))
    
for i in range(1, n + 1):
    nums[i] += nums[i - 1]
    
cnt = Counter()
cnt[0] += 1
for i in range(1, n + 1):
    ans += cnt[nums[i] % k]
    cnt[nums[i] % k] += 1
    

print(ans)
```

前缀和大妙招，确实是dp思想，记录过程

注意到有等式 `not (nums[j] - nums[i - 1]) % k`，即 `(nums[j] - nums[i - 1]) % k == 0` 可推导成 `nums[j] % k == nums[i - 1] % k`，因此题目变成了求对于每一个 `nums[j]` 在之前出现过相同值的个数的问题，可利用 `cnt` 记录出现过的余数值

这里有个细节需要注意，对于 `cnt[0]` 而言是满足条件的因此需要需处理



#### AcWing 4312. 出现次数 

```python
n, m, q = map(int, input().split())
s = ' ' + input()
t = input()

ll = [0 for _ in range(n + 1)]
for i in range(m, n + 1):
    ll[i] = ll[i - 1]
    if s[i - m + 1 : i + 1] == t:
        ll[i] += 1

for _ in range(q):
    l, r = map(int, input().split())
    if m <= n and r - l + 1 >= m:
        print(ll[r] - ll[l + m - 2])
    else:
        print(0)
```

本题思想在蜡烛之间的盘子也出现过，前缀和除了用来求和同样可以用来记录目标值出现次数，与蜡烛那题相同的，除了记录次数之外还需要对询问值进行修改，这也是本题最难的地方，存在两个细节：

- 字符串 `t` 应该比 `s` 小
- `r`  与 `l` 之间应该有 `m` 的长度



## 差分

- 降维实现大规模修改矩阵
- 例子

```python
# 全 0 数组，在[2, 3]间每个数加一
nums = [0] * 5
# 从nums[2]开始往后每一位都加一
nums[2] += 1
# 从nums[3]开始往后每一位都减一
nums[3 + 1] -= 1
# 进行前缀和操作
for i in range(1, len(nums)):
    nums[i] += nums[i - 1]
# [0, 0, 1, 1, 0]
```

- 模板

```python
# 数组 nums 中 l 到 r 加 k
nums[l] += k
nums[r + 1] -= k
for i in range(1, len(nums)):
    nums[i] += nums[i - 1]
```



### [798. 得分最高的最小轮调](https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/)

> 模拟超时

```python
class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        c, n = Counter(), len(nums)
        for i, num in enumerate(nums):
            d = i - num
            if (d:= i - num) < 0:
                a = Counter([j for j in range(i + 1, n + d + 1)])
                c += a
            else:
                b = Counter([j for j in range(0, d + 1)])
                d= Counter([j for j in range(i + 1, n)])
                c += b + d

        mini, maxvalue = c.most_common(1)[0]
        for i, v in c.most_common():
            if v < maxvalue:
                break
            if i < mini:
                mini = i
        
        return mini
```

> 尝试用差分优化，替换Counter

```python
# 利用差分记录区间信息
class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        diff, n = [0] * (len(nums) + 1), len(nums)
        for i, num in enumerate(nums):
            if (d:= i - num) < 0:
                diff[i + 1] += 1
                diff[n + d + 1] -= 1
            else:
                diff[0] += 1
                diff[d + 1] -= 1
                diff[i + 1] += 1
        minid = maxvalue = score = 0
        for i in range(n):
            score += diff[i]
            if score > maxvalue:
                minid, maxvalue = i, score
        return minid
```

观察区间不难发现，无论是 `d < 0` 还是反之，可选区间一直都是在以 `n` 为进制内连续的，进而发现新的公式免除判断

```python
class Solution:
    def bestRotation(self, nums: List[int]) -> int:
        n = len(nums)
        diffs = [0] * n
        for i, num in enumerate(nums):
            low = (i + 1) % n
            high = (i + 1 + n - num) % n
            diffs[low] += 1
            diffs[high] -= 1
            if low >= high:
                diffs[0] += 1
        score, maxScore, idx = 0, 0, 0
        for i, diff in enumerate(diffs):
            score += diff
            if score > maxScore:
                maxScore, idx = score, i
        return idx
```

