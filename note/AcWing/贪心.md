- 题目中出现最大最小

###  [1414. 和为 K 的最少斐波那契数字数目](https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/)

```python
class Solution:
    def findMinFibonacciNumbers(self, k: int) -> int:
        f, ans = [1, 1], 0
        while k > f[-1]:
            f.append(f[-1] + f[-2])

        i = len(f) - 1
        while k:
            if k >= f[i]:
                k -= f[i]
                ans += 1
            i -= 1
        return ans        
```

题目要求选取最小的数目，即可考虑贪心下，用k去减列表中`>= k`的第一个值，也就是去减能减的最大值



### [1405. 最长快乐字符串](https://leetcode-cn.com/problems/longest-happy-string/)

```python
class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        ans, cnt = [], [[a, 'a'], [b, 'b'], [c, 'c']]
        while True:
            # 本题每次选取都进行一次sort()，相当于一个大根堆的效果
            cnt.sort(key = lambda x: -x[0])
            
            # hasNext用来判断是否完成循环，既符合结束条件
            hasNext = False
            for i, (c, ch) in enumerate(cnt):
                # 当前值为0时结束，因为是大根堆，当前值为0时必然结束
                if c <= 0:  break
                
                # 当前面两个字母已经与当前字母相同时跳过本层循环
                if len(ans) > 1 and ans[-1] == ch and ans[-2] == ch: continue
                ans.append(ch)
                cnt[i][0] -= 1
                hasNext = True
                break
            if not hasNext:
                return "".join(ans)
```

本题同样使用贪心解题，除了选取最大值外，还有一个限制条件是要求不能重复三次出现同一个值，因此本题的解法即在于满足最多只能连续出现两次同一个值的条件下选择剩余数量最多的值。正因为是贪心解法，每次只加入一个值，因此需要两个`break`来维护循环，保证两种结束条件：

- 三个字母剩余值均为0

- 已有两个剩余值为0，而当前值已被用了两次



### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        maxd = 0
        for i, v in enumerate(nums):
            if maxd >= i and i + v > maxd:
                maxd = i + v
        return maxd >= i
```

